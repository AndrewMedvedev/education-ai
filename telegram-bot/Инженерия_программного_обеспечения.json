{
  "id": "d845aba3-c017-4754-aa97-9a6754a4c9e2",
  "created_at": "2026-02-14T16:30:33.259112+03:00",
  "creator_id": 123,
  "status": "in_progress",
  "image_url": null,
  "title": "Сценарий курса: Инженерия программного обеспечения",
  "description": "Модульный курс для студентов 3 курса IT-направлений, построенный на сквозном проекте, кейсах реальных провалов и практико-ориентированной логике. Акцент — на развитие инженерного мышления, командной работы и профессиональных артефактов.",
  "learning_objectives": [
    "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
    "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
    "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
    "Применять методологии Agile (Scrum) для управления учебным проектом.",
    "Реализовать и протестировать систему, используя практики CI/CD и автоматизированного тестирования.",
    "Создать техническую документацию по ГОСТ и современным стандартам.",
    "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
  ],
  "modules": [
    {
      "id": "af51b89a-6b1f-4e30-8f61-68acad476ff8",
      "title": "Модуль 0: Введение в инженерное мышление и жизненный цикл ПО",
      "description": "Первый шаг к системному подходу в разработке программного обеспечения. В этом модуле студенты познакомятся с фундаментальными концепциями инженерии ПО, осознают важность структурированного подхода и выйдут за рамки «написания кода» к пониманию полного жизненного цикла создания систем. Модуль закладывает основы для дальнейшего освоения моделирования, управления требованиями, архитектуры и процессов разработки.",
      "learning_objectives": [
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
        "Применять методологии Agile (Scrum) для управления учебным проектом.",
        "Реализовать и протестировать систему, используя практики CI/CD и автоматизированного тестирования.",
        "Создать техническую документацию по ГОСТ и современным стандартам.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 0,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 0: Введение в инженерное мышление и жизненный цикл ПО] --> B[Тема 1: От кодера к инженеру ПО]\n    A --> C[Тема 2: Жизненный цикл программного обеспечения]\n    A --> D[Тема 3: Типичные ошибки в IT-проектах и уроки из провалов]\n    A --> E[Тема 4: Основы системного и инженерного мышления]\n    A --> F[Тема 5: Введение в управление требованиями]\n    A --> G[Практикум: Анализ кейса провального проекта]\n```",
          "explanation": ""
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 1: От кодера к инженеру ПО\n\n#### Различие между программистом и инженером ПО\n\nПрограммист и инженер программного обеспечения — эти термины часто используются как синонимы, однако между ними существует принципиальная разница, связанная с подходом, масштабом ответственности и методологией работы.\n\n**Программист** — это специалист, сосредоточенный в первую очередь на написании кода. Его основная задача — реализовать конкретную функцию или алгоритм, решить техническую задачу. Работа программиста может быть эффективной в рамках небольших проектов или при выполнении отдельных задач, но она часто ограничивается «здесь и сейчас».\n\n**Инженер ПО** — это системный мыслитель, который рассматривает программное обеспечение как сложную систему, требующую проектирования, анализа, тестирования, сопровождения и управления на всех этапах жизненного цикла. Он не просто пишет код, а проектирует архитектуру, формулирует требования, оценивает риски, документирует решения и обеспечивает долгосрочную поддержку системы.\n\nПример: программист может написать скрипт, который парсит данные с сайта. Инженер ПО задумается о масштабируемости, обработке ошибок, логировании, безопасности, тестировании, интеграции в CI/CD и поддержке в будущем.\n\n#### Что такое инженерная культура: ответственность, прогнозируемость, документирование\n\nИнженерная культура — это совокупность ценностей, практик и норм, которые обеспечивают надёжность, предсказуемость и устойчивость разработки ПО. Она включает в себя:\n\n- **Ответственность** — каждый член команды отвечает не только за свой код, но и за его влияние на систему в целом. Это включает в себя соблюдение сроков, качество кода, участие в ревью и готовность исправлять ошибки.\n- **Прогнозируемость** — процессы разработки должны быть стабильными и предсказуемыми. Это достигается за счёт использования методологий (например, Scrum), планирования, оценки задач и прозрачности процессов.\n- **Документирование** — все ключевые решения, архитектурные изменения, требования и процессы фиксируются. Документация — не бюрократия, а средство коммуникации, передачи знаний и обеспечения преемственности.\n\nИнженерная культура предполагает, что команда работает как единый механизм, где каждый элемент важен, а процессы стандартизированы.\n\n#### Примеры ситуаций, где «просто код» не работает\n\n1. **Масштабирование системы** — приложение, написанное «на коленке» без архитектуры, может работать на 10 пользователях, но рушится при нагрузке в 10 000.\n2. **Смена команды** — если код не задокументирован и не следует стандартам, новая команда тратит недели на разбор «чёрного ящика».\n3. **Интеграция с другими системами** — отсутствие чётких интерфейсов и спецификаций приводит к ошибкам и задержкам.\n4. **Безопасность** — «просто код» часто игнорирует уязвимости, что приводит к утечкам данных и атакам.\n5. **Поддержка и обновления** — без тестов, документации и модульной архитектуры внесение изменений становится рискованным.\n\n#### Роль дисциплины, процессов и стандартов в разработке\n\nДисциплина — это основа инженерного подхода. Она проявляется в:\n\n- Соблюдении сроков и планов.\n- Проведении код-ревью.\n- Написании тестов до и после реализации.\n- Следовании стандартам кодирования (например, PEP 8, Google Java Style).\n\nПроцессы (например, Scrum, Kanban, Waterfall) обеспечивают структуру разработки, позволяют управлять сложностью, распределять задачи и отслеживать прогресс.\n\nСтандарты (ГОСТ, ISO/IEC 12207, IEEE) задают единые правила для разработки, документирования, тестирования и сопровождения ПО. Они повышают качество, снижают риски и облегчают взаимодействие между командами и организациями.\n\n**Вывод**: переход от «кодера» к «инженеру ПО» — это переход от тактического мышления к стратегическому. Это путь от решения частных задач к созданию надёжных, масштабируемых и поддерживаемых систем."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 2: Жизненный цикл программного обеспечения\n\nЖизненный цикл программного обеспечения (ЖЦ ПО) — это структурированный процесс, охватывающий все этапы создания, эксплуатации и вывода из употребления программной системы. Понимание и соблюдение этапов жизненного цикла позволяет командам разрабатывать качественное, надёжное и поддерживаемое ПО, минимизируя риски и затраты.\n\n#### Этапы жизненного цикла ПО\n\n1. **Анализ требований**  \n   На этом этапе определяются цели системы, собираются и анализируются функциональные и нефункциональные требования от заказчика и конечных пользователей. Результат — документ спецификации требований (SRS), включающий пользовательские истории, диаграммы прецедентов (Use Case), ограничения по производительности, безопасности и другим критериям.\n\n2. **Проектирование**  \n   На основе требований разрабатывается архитектура системы: выбирается технологический стек, определяется структура компонентов, взаимодействие между ними, базы данных, интерфейсы. Используются UML-диаграммы: классов, последовательностей, состояний и развёртывания.\n\n3. **Реализация (разработка)**  \n   Программисты пишут код в соответствии с проектной документацией. На этом этапе применяются принципы чистого кода, контроль версий (Git), code review и автоматизированная сборка.\n\n4. **Тестирование**  \n   Проверка корректности работы системы: поиск и устранение ошибок. Включает модульное, интеграционное, системное и приёмочное тестирование. Автоматизированные тесты и CI/CD-пайплайны позволяют быстро выявлять регрессии.\n\n5. **Внедрение**  \n   Перевод системы в эксплуатацию: развёртывание на продакшн-серверах, миграция данных, обучение пользователей. Может проводиться поэтапно (канареечное развертывание, A/B-тестирование) или полностью.\n\n6. **Сопровождение**  \n   Поддержка работоспособности системы: исправление ошибок, обновление функционала, адаптация к новым требованиям и средам. Этот этап может длиться годами и потреблять до 60–70% общих затрат на проект.\n\n---\n\n#### Модели жизненного цикла\n\nВыбор модели ЖЦ определяет порядок выполнения этапов и подход к управлению проектом. Ниже рассмотрены основные модели:\n\n1. **Каскадная модель (Waterfall)**  \n   - **Описание**: Линейная модель, в которой каждый этап завершается перед началом следующего.  \n   - **Плюсы**: Простота управления, чёткая документация, предсказуемость сроков и бюджета.  \n   - **Минусы**: Низкая гибкость, трудно вносить изменения после начала разработки, позднее выявление ошибок.  \n   - **Применение**: Проекты с чётко определёнными и стабильными требованиями (например, в авиации, обороне, промышленной автоматике).\n\n2. **Спиральная модель**  \n   - **Описание**: Комбинирует итеративный подход и каскадную модель с акцентом на управление рисками. Каждый виток спирали включает планирование, анализ рисков, разработку и оценку.  \n   - **Плюсы**: Высокая управляемость рисков, возможность корректировки требований.  \n   - **Минусы**: Сложность в управлении, высокая стоимость, требует экспертизы в оценке рисков.  \n   - **Применение**: Крупные, сложные проекты с высокой неопределённостью (например, банковские системы, медицинские комплексы).\n\n3. **Итерационная модель**  \n   - **Описание**: Разработка ведётся циклами (итерациями), на каждой из которых создаётся работающая версия системы с расширяющимся функционалом.  \n   - **Плюсы**: Ранняя демонстрация продукта, возможность получения обратной связи, постепенное уточнение требований.  \n   - **Минусы**: Требует хорошего управления архитектурой, возможен «дрейф» требований без чёткого контроля.  \n   - **Применение**: Проекты со сложной логикой, где требования частично известны (например, CRM-системы, платформы электронной коммерции).\n\n4. **Agile (гибкие методологии)**  \n   - **Описание**: Подход, основанный на итеративной разработке, постоянной обратной связи и адаптации. Наиболее популярные фреймворки — Scrum, Kanban.  \n   - **Плюсы**: Высокая гибкость, быстрая реакция на изменения, тесное взаимодействие с заказчиком, постоянная доставка ценности.  \n   - **Минусы**: Требует высокой дисциплины команды, сложность в прогнозировании бюджета и сроков, недостаток документации.  \n   - **Применение**: Динамичные проекты с изменяющимися требованиями (стартапы, цифровые продукты, мобильные приложения).\n\n---\n\n#### Сравнение моделей\n\n| Модель         | Гибкость | Риски | Документация | Управление | Обратная связь |\n|----------------|----------|-------|--------------|------------|----------------|\n| Каскадная      | Низкая   | Высокие при ошибках | Высокая | Простое | Поздняя |\n| Спиральная     | Средняя  | Управляемые | Высокая | Сложное | По итерациям |\n| Итерационная   | Высокая  | Средние | Средняя | Среднее | Ранняя |\n| Agile          | Очень высокая | Низкие | Низкая | Гибкое | Постоянная |\n\n---\n\n#### Влияние выбора модели на успех проекта\n\nВыбор модели жизненного цикла напрямую влияет на:\n\n- **Качество продукта**: Agile и итерационные модели способствуют более высокому качеству за счёт регулярного тестирования и обратной связи.\n- **Сроки и бюджет**: Каскадная модель предсказуема, но рискованна при изменениях; Agile позволяет адаптироваться, но требует гибкого финансирования.\n- **Удовлетворённость заказчика**: Agile обеспечивает постоянное вовлечение заказчика, что повышает шансы на соответствие ожиданиям.\n- **Управление рисками**: Спиральная модель специально ориентирована на минимизацию рисков, тогда как каскадная может привести к критическим срывам.\n\n**Вывод**: Нет универсальной модели. Успешный проект требует осознанного выбора модели в зависимости от характера требований, масштаба, уровня неопределённости и компетенций команды. Современные практики всё чаще комбинируют подходы (например, гибридные модели: Waterfall для анализа, Agile для разработки), что позволяет извлекать преимущества из разных стратегий."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 3: Типичные ошибки в IT-проектах и уроки из провалов\n\nРазработка программного обеспечения — это сложный процесс, в котором даже небольшие просчёты могут привести к катастрофическим последствиям. Анализ реальных провалов IT-проектов позволяет выявить системные ошибки и сформировать лучшие практики, предотвращающие подобные ситуации в будущем. Рассмотрим несколько знаковых кейсов, извлечённых из них уроков и способы минимизации рисков.\n\n#### Анализ реальных кейсов провалов\n\n**1. Healthcare.gov (США, 2013)**\n\nСайт Healthcare.gov был запущен как центральный элемент реформы здравоохранения в США. Однако при запуске сайт не выдержал нагрузки: пользователи не могли зарегистрироваться, страницы зависали, транзакции прерывались.\n\n**Причины провала**:\n- Отсутствие нагрузочного тестирования перед запуском.\n- Недостаточная интеграция между подсистемами, разработанными разными командами.\n- Позднее вовлечение специалистов по тестированию и DevOps.\n- Политическое давление, приведшее к неоправданно жёстким срокам.\n\n**Урок**: Даже при политических или бизнес-давлениях нельзя пропускать ключевые этапы жизненного цикла ПО, особенно тестирование и интеграцию.\n\n**2. Knight Capital Group (2012)**\n\nАмериканская торговая компания потеряла $440 млн за 45 минут из-за ошибки в программном обеспечении для алгоритмического трейдинга.\n\n**Причина**: При обновлении системы старый, неиспользуемый код был активирован из-за ошибки в скрипте развёртывания. Это привело к неконтролируемым сделкам.\n\n**Уроки**:\n- Отсутствие системы контроля версий и тестирования в production-среде.\n- Недостаточная автоматизация развёртывания и отсутствие rollback-механизмов.\n- Игнорирование практик CI/CD и управления конфигурациями.\n\n**3. Ariane 5 (1996)**\n\nРакета Ariane 5 взорвалась через 37 секунд после старта. Причиной стал сбой в программном обеспечении, перенесённом с Ariane 4 без адаптации.\n\n**Техническая причина**: Переполнение целочисленной переменной при преобразовании скорости. Ошибка возникла из-за того, что код не был протестирован в новых условиях полёта.\n\n**Уроки**:\n- Нельзя переносить ПО без полного анализа контекста и требований.\n- Отказоустойчивость и обработка исключений критически важны в системах реального времени.\n- Тестирование должно учитывать все возможные сценарии, включая выход за границы штатных условий.\n\n#### Основные причины провалов IT-проектов\n\n1. **Отсутствие анализа требований**\n   - Нечёткие, неполные или противоречивые требования — частая причина отклонения от цели.\n   - Решение: использование UML, пользовательских историй, прототипирования и постоянная обратная связь с заказчиком.\n\n2. **Игнорирование тестирования**\n   - Отказ от unit-, интеграционного, нагрузочного и приёмочного тестирования приводит к накоплению дефектов.\n   - Решение: внедрение автоматизированного тестирования и практик CI/CD.\n\n3. **Плохое управление изменениями**\n   - Неконтролируемые изменения в коде, архитектуре или требованиях нарушают стабильность проекта.\n   - Решение: использование систем контроля версий, процессов code review и управления конфигурациями.\n\n4. **Недостаточная документация**\n   - Отсутствие технической и пользовательской документации затрудняет сопровождение и передачу знаний.\n   - Решение: ведение документации по стандартам (например, ГОСТ, ISO/IEC 26514).\n\n#### Роль человеческого фактора и организационной культуры\n\nМногие провалы начинаются не с кода, а с культуры команды:\n- **Страх сообщить о проблеме** — сотрудники боятся наказания за ошибки, что приводит к сокрытию дефектов.\n- **Отсутствие кросс-функциональной коммуникации** — разработчики, тестировщики и аналитики работают в «силосах».\n- **Выгорание и перегрузка** — приводят к снижению качества и увеличению количества ошибок.\n\n**Решение**: Формирование культуры доверия, внедрение Agile-практик (например, ретроспективы в Scrum), прозрачность процессов и поддержка психологической безопасности в команде.\n\n#### Как избежать типичных ловушек\n\n- **Применяйте полный жизненный цикл ПО**: от анализа до сопровождения.\n- **Формализуйте требования** с помощью UML, user stories и acceptance criteria.\n- **Тестируйте на всех уровнях** и автоматизируйте процессы.\n- **Управляйте изменениями** с помощью контроля версий и процессов утверждения.\n- **Формируйте здоровую командную культуру**, где ошибки — это возможность для роста.\n- **Проводите постмортем-анализ** после завершения проектов (успешных и провальных) для извлечения уроков.\n\n> **Вывод**: Провалы в IT — не приговор, а ценный источник знаний. Системный подход, дисциплина и культура непрерывного улучшения — ключ к созданию надёжного и устойчивого программного обеспечения."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 4: Основы системного и инженерного мышления\n\n#### Что такое системный подход: компоненты, взаимодействия, границы системы\n\nСистемный подход — это метод анализа и проектирования, при котором объект (в нашем случае — программное обеспечение) рассматривается как целостная система, состоящая из взаимосвязанных компонентов, функционирующих в определённой среде для достижения общей цели.\n\n**Ключевые элементы системного подхода:**\n\n- **Компоненты системы** — это отдельные части, из которых состоит система. В контексте ПО это могут быть модули, сервисы, базы данных, интерфейсы и т.д. Каждый компонент выполняет определённую функцию.\n- **Взаимодействия** — связи и обмен данными между компонентами. Например, веб-приложение может взаимодействовать с базой данных через API, а пользователь — с интерфейсом приложения.\n- **Границы системы** — чётко определённая линия, разделяющая систему и внешнюю среду. Важно понимать, что входит в систему, а что — внешние сущности (например, пользователи, сторонние сервисы). Это помогает избежать неопределённости при проектировании.\n\nПример: при разработке интернет-магазина система включает корзину, каталог, платёжный шлюз, пользовательский интерфейс. Внешние сущности — покупатели, поставщики, банковские системы.\n\n#### Принципы инженерного мышления: декомпозиция, абстракция, модульность\n\nИнженерное мышление — это способ решения сложных задач, основанный на логике, структурированности и повторяемости. В отличие от «программистского» мышления (написание кода «здесь и сейчас»), инженерный подход предполагает проектирование, анализ и управление сложностью.\n\n**Основные принципы:**\n\n- **Декомпозиция** — разбиение сложной системы на более простые, управляемые части. Например, разработка приложения для доставки еды может быть разбита на модули: авторизация, меню, заказ, оплата, отслеживание.\n- **Абстракция** — сосредоточение на существенных аспектах системы и игнорирование второстепенных деталей. Например, при проектировании интерфейса пользователя не нужно знать, как именно реализована бизнес-логика — достаточно знать, какие данные и в каком формате она возвращает.\n- **Модульность** — организация системы в виде независимых, заменяемых модулей, которые можно разрабатывать, тестировать и обновлять отдельно. Это упрощает сопровождение и масштабирование.\n\nЭти принципы позволяют управлять сложностью, снижать риски ошибок и повышать качество продукта.\n\n#### Понятие качества ПО: надёжность, масштабируемость, сопровождаемость\n\nКачество программного обеспечения — это совокупность характеристик, определяющих, насколько хорошо система удовлетворяет требованиям пользователей и разработчиков.\n\n**Ключевые атрибуты качества ПО:**\n\n- **Надёжность** — способность системы корректно работать в течение длительного времени, даже при сбоях. Включает устойчивость к ошибкам, восстановление после сбоев, отказоустойчивость.\n- **Масштабируемость** — возможность системы эффективно справляться с ростом нагрузки (например, увеличение числа пользователей). Масштабирование может быть вертикальным (усиление сервера) или горизонтальным (добавление серверов).\n- **Сопровождаемость** — лёгкость внесения изменений, исправления ошибок и добавления новых функций. Хорошо документированный, модульный код проще поддерживать.\n\nДругие важные атрибуты: производительность, безопасность, удобство использования, переносимость.\n\n#### Важность прогнозирования и проектирования до написания кода\n\nОдна из главных ошибок начинающих разработчиков — «прыгать в код» без предварительного анализа и проектирования. Это приводит к:\n\n- Появлению архитектурных ошибок на поздних стадиях;\n- Увеличению стоимости исправлений;\n- Потере времени и ресурсов;\n- Низкому качеству итогового продукта.\n\n**Преимущества проектирования до кодирования:**\n\n- Чёткое понимание требований и границ системы;\n- Возможность выявить риски и сложности на раннем этапе;\n- Эффективное распределение задач среди команды;\n- Создание архитектуры, соответствующей целям проекта;\n- Упрощение тестирования и сопровождения.\n\nПроектирование включает создание моделей (Use Case, диаграммы классов, последовательности), определение технологического стека, архитектурных решений (например, монолит vs микросервисы) и плана реализации.\n\n**Вывод:** системный и инженерный подходы — основа профессиональной разработки ПО. Они превращают хаотичное написание кода в управляемый, предсказуемый процесс, ориентированный на долгосрочное качество и успех проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5: Введение в управление требованиями\n\nУправление требованиями — один из ключевых аспектов инженерии программного обеспечения, определяющий успех или провал проекта. От того, насколько точно и полно сформулированы требования, зависит, будет ли созданная система соответствовать ожиданиям пользователей и бизнеса. В этой теме мы рассмотрим основные типы требований, проблемы, связанные с их неопределённостью, а также инструменты для их эффективного описания и визуализации.\n\n#### Функциональные и нефункциональные требования: определение, примеры\n\n**Функциональные требования** описывают, *что* должна делать система — её поведение, функции и возможности. Они отвечают на вопрос: «Какие задачи система должна выполнять?»\n\n**Примеры функциональных требований:**\n- Пользователь может авторизоваться в системе, используя логин и пароль.\n- Система должна позволять добавлять, редактировать и удалять товары в каталоге.\n- При оформлении заказа система рассчитывает итоговую стоимость с учётом скидок.\n\n**Нефункциональные требования** определяют *качество* системы — условия, в которых она должна работать, и ограничения на её поведение. Они отвечают на вопросы: «Как хорошо система должна работать?», «Какие ограничения существуют?»\n\n**Примеры нефункциональных требований:**\n- Система должна обрабатывать до 1000 запросов в секунду (производительность).\n- Время отклика системы не должно превышать 2 секунды при нормальной нагрузке (отзывчивость).\n- Данные пользователей должны храниться в зашифрованном виде (безопасность).\n- Интерфейс должен быть доступен на русском и английском языках (локализация).\n- Система должна быть доступна 99,9% времени в течение года (надёжность).\n\n#### Проблемы несформулированных или меняющихся требований\n\nНа практике требования редко бывают полными и стабильными с самого начала. Часто они уточняются по ходу разработки, что может привести к серьёзным последствиям:\n\n- **Рост стоимости проекта** — каждое изменение требует переработки кода, тестирования и документации.\n- **Задержки в сроках** — непредвиденные изменения нарушают план разработки.\n- **Недовольство заказчика** — если система не соответствует ожиданиям, даже при технической корректности.\n- **Технический долг** — спешка при внедрении изменений может привести к ухудшению архитектуры.\n\nИсследования показывают, что **до 70% провалов IT-проектов** связаны с плохим управлением требованиями (по данным Standish Group, CHAOS Report). Поэтому важно использовать системные подходы к их сбору, анализу и отслеживанию.\n\n#### Пользовательские истории как инструмент описания требований\n\nВ гибких методологиях (Agile) требования часто формулируются в виде **пользовательских историй** — кратких описаний функциональности с точки зрения конечного пользователя.\n\nФормат пользовательской истории:\n> «Как [роль], я хочу [цель], чтобы [выгода]».\n\n**Примеры:**\n- «Как покупатель, я хочу добавлять товары в корзину, чтобы оформить заказ позже».\n- «Как администратор, я хочу видеть отчёт по продажам, чтобы анализировать эффективность».\n\nПреимущества пользовательских историй:\n- Простота понимания для всех участников.\n- Фокус на ценности для пользователя.\n- Гибкость — легко дополнять и изменять.\n\nКаждая история может сопровождаться **критериями принятия** — условиями, при которых она считается выполненной.\n\n#### Введение в UML: диаграмма прецедентов (Use Case) — базовые элементы\n\n**UML (Unified Modeling Language)** — стандартный язык визуального моделирования, используемый для описания структуры и поведения программных систем.\n\n**Диаграмма прецедентов (Use Case Diagram)** — один из первых инструментов анализа требований. Она показывает:\n- Кто взаимодействует с системой (акторы).\n- Что система может делать (прецеденты).\n- Как акторы используют функции системы.\n\n**Основные элементы диаграммы:**\n\n1. **Актор (Actor)** — внешняя сущность, взаимодействующая с системой (пользователь, другая система). Обозначается человечком.\n2. **Прецедент (Use Case)** — функция или действие, которое система выполняет для актора. Обозначается овалом.\n3. **Связь (Association)** — линия, показывающая взаимодействие актора с прецедентом.\n4. **Система (System Boundary)** — прямоугольник, ограничивающий прецеденты и показывающий границы системы.\n5. **Отношения между прецедентами:**\n   - `include` — обязательное включение одного прецедента в другой.\n   - `extend` — опциональное расширение прецедента.\n\n**Пример диаграммы прецедентов для интернет-магазина:**\n- Акторы: Покупатель, Администратор.\n- Прецеденты: «Войти в систему», «Просмотреть каталог», «Оформить заказ», «Управление товарами».\n\nДиаграмма прецедентов помогает визуализировать требования, выявить пробелы и согласовать понимание системы между заказчиком и разработчиками.\n\n---\n\n**Вывод:** Управление требованиями — это не просто формальность, а основа успешной разработки ПО. Грамотное описание функциональных и нефункциональных требований, использование пользовательских историй и UML-диаграмм позволяют минимизировать риски, улучшить коммуникацию и создавать системы, которые действительно решают задачи пользователей."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Практикум: Анализ кейса провального проекта\n\n#### Задание\nСтуденты делятся на группы по 3–5 человек и получают задание проанализировать один из известных провальных IT-проектов. Примеры кейсов могут быть взяты из авторитетных источников, таких как:\n- Отчёты IEEE (Institute of Electrical and Electronics Engineers)\n- Публикации на The Register, ZDNet, Ars Technica\n- Postmortem-анализы с сайтов крупных компаний (например, Postmortems.org, GitHub Postmortem)\n- Истории из книг по управлению проектами (например, *«The Mythical Man-Month»* Фредерика Брукса)\n\n**Примеры кейсов для анализа:**\n- Провал запуска Healthcare.gov (США, 2013)\n- Авария ракеты Ariane 5 (1996) из-за ошибки программного обеспечения\n- Ошибки в системе Therac-25, приведшие к смертельным дозам облучения\n- Крах системы Knight Capital (2012) из-за развертывания непроверенного кода\n- Провал проекта FBI по созданию системы Virtual Case File\n\n#### Этапы выполнения задания\n\n1. **Выбор и изучение кейса**\n   - Группа выбирает один провальный проект и собирает информацию о его целях, ходе реализации и причинах провала.\n   - Используются открытые источники, технические отчёты, журналистские расследования и официальные postmortem-документы.\n\n2. **Анализ жизненного цикла ПО**\n   - Студенты сопоставляют ход проекта с этапами жизненного цикла разработки ПО:\n     - Анализ требований\n     - Проектирование\n     - Реализация\n     - Тестирование\n     - Внедрение\n     - Сопровождение\n   - Определяется, на каком этапе впервые проявились критические ошибки.\n\n3. **Выявление отсутствующих инженерных практик**\n   - Группа анализирует, какие инженерные подходы не были применены или были нарушены:\n     - Отсутствие формализованных требований\n     - Недостаточное тестирование (включая unit- и интеграционное)\n     - Отсутствие документации\n     - Неконтролируемые изменения (отсутствие управления конфигурацией)\n     - Игнорирование рисков и отсутствие резервных планов\n     - Нарушение принципов Agile (например, отсутствие регулярных ретроспектив)\n\n4. **Разработка рекомендаций**\n   - На основе анализа формулируются практические рекомендации:\n     - Какие методологии (например, Scrum, Waterfall с валидацией) могли бы предотвратить провал\n     - Какие инструменты (CI/CD, системы отслеживания багов, UML-моделирование) следовало использовать\n     - Как улучшить коммуникацию между командами и заинтересованными сторонами\n\n5. **Подготовка презентации (5–7 минут)**\n   - Краткий обзор проекта\n   - Визуализация ключевых ошибок (можно использовать диаграмму Ганта, схему жизненного цикла с отметками сбоев)\n   - Перечень упущенных инженерных практик\n   - Рекомендации по предотвращению подобных кейсов в будущем\n\n#### Цель практикума\n- Развитие **критического мышления** у студентов\n- Понимание **реальных последствий** отсутствия инженерной дисциплины\n- Осознание ценности **системного подхода**, документирования, тестирования и управления изменениями\n- Формирование навыков **работы в команде** и анализа сложных ситуаций\n\n#### Результат\nКаждая группа представляет свой анализ перед аудиторией. Преподаватель проводит обсуждение, акцентируя внимание на общих паттернах провалов и том, как современные методологии и практики инженерии ПО позволяют избегать подобных катастроф."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Результаты обучения модуля\n\nК концу модуля студенты смогут:\n\n- **Объяснить разницу между программированием и инженерией ПО**\n  — Понимать, что программирование — это лишь один из этапов создания программного обеспечения, тогда как инженерия ПО охватывает весь жизненный цикл: анализ требований, проектирование, разработку, тестирование, внедрение, сопровождение и управление изменениями. Студенты научатся мыслить системно, учитывая не только техническую реализацию, но и качество, масштабируемость, поддерживаемость и соответствие бизнес-целям.\n\n- **Описать основные этапы жизненного цикла ПО и выбрать подходящую модель разработки**\n  — Освоят ключевые модели жизненного цикла: водопадную, итеративную, спиральную, V-модель и Agile-подходы. Научатся соотносить особенности проекта (объём, неопределённость требований, сроки, команда) с выбором оптимальной модели. Особое внимание будет уделено гибким методологиям, таким как Scrum, и их применению в условиях изменяющихся требований.\n\n- **Проанализировать причины провала реальных IT-проектов и предложить меры по предотвращению подобных ситуаций**\n  — Изучат кейсы проваленных проектов (например, проект Healthcare.gov, система FBI Sentinel, ошибки в банковских системах) и выявят типичные причины: плохое управление требованиями, отсутствие тестирования, игнорирование рисков, недостаточная коммуникация в команде. На основе анализа разработают стратегии предотвращения — введение прозрачного планирования, регулярные ревью, управление рисками и поэтапная доставка продукта.\n\n- **Применять базовые принципы системного мышления при анализе задач**\n  — Научатся рассматривать ПО как часть более широкой системы, учитывая взаимодействие компонентов, пользователей, внешних систем и бизнес-процессов. Будут использовать такие концепции, как границы системы, входы/выходы, обратная связь и иерархия, чтобы глубже понимать задачу и избегать узких технических решений.\n\n- **Формулировать простые функциональные требования в виде пользовательских историй и Use Case**\n  — Освоят практики Agile по формулировке требований: «Как [роль], я хочу [действие], чтобы [цель]». Научатся строить диаграммы прецедентов (Use Case), выделять акторов и сценарии взаимодействия, а также документировать основной и альтернативные потоки событий.\n\n- **Осознать важность документирования, планирования и дисциплины в разработке ПО**\n  — Поймут, что качественная документация (по ГОСТ и современным стандартам), регулярное планирование спринтов, ведение бэклога и соблюдение процессов — не формальность, а основа надёжной и предсказуемой разработки. Осознают ценность дисциплины, прозрачности и ответственности в командной работе."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 0: Введение в инженерное мышление и жизненный цикл ПО",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Опишите ключевые различия между программистом и инженером программного обеспечения. Приведите пример из реальной практики, в котором подход программиста мог бы привести к проблемам, а инженерный подход — позволил бы их избежать. Объясните, какие аспекты жизненного цикла ПО в этом случае были бы задействованы.",
            "options": [],
            "correct_answers": [],
            "points": 20
          }
        ]
      }
    },
    {
      "id": "70d2d348-3b95-4dec-897c-b10310818b66",
      "title": "Модуль 1: Основы жизненного цикла ПО и анализ требований",
      "description": "В этом модуле студенты познакомятся с полным жизненным циклом разработки программного обеспечения, научатся выявлять, анализировать и формализовать требования к системе. Особое внимание уделено пониманию разницы между функциональными и нефункциональными требованиями, а также важности системного подхода на ранних этапах разработки. Студенты освоят методы сбора требований, научатся работать с пользователями и заинтересованными сторонами, а также начнут подготовку к проектированию с использованием стандартизированных подходов.",
      "learning_objectives": [
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 1,
      "content_blocks": [
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Введение в жизненный цикл программного обеспечения\n\nЖизненный цикл программного обеспечения (ЖЦ ПО) — это совокупность взаимосвязанных процессов, которые проходит программная система от момента возникновения идеи до её полного вывода из эксплуатации. Понимание и соблюдение этапов жизненного цикла критически важно для успешной разработки качественного, надёжного и соответствующего потребностям ПО.\n\n### Основные этапы жизненного цикла ПО\n\nХотя конкретные модели могут варьироваться, типичный жизненный цикл включает следующие ключевые этапы:\n\n1. **Формирование требований** — выявление и анализ потребностей пользователей и заинтересованных сторон.\n2. **Анализ и проектирование** — разработка архитектуры системы, определение структуры, интерфейсов и компонентов.\n3. **Реализация (разработка)** — написание кода в соответствии с проектом.\n4. **Тестирование** — проверка корректности работы системы, выявление и устранение ошибок.\n5. **Внедрение** — установка и настройка системы в рабочей среде.\n6. **Эксплуатация и сопровождение** — поддержка системы, исправление ошибок, обновления и адаптация к новым условиям.\n7. **Завершение жизненного цикла** — постепенный вывод системы из эксплуатации.\n\n### Модели жизненного цикла\n\nСуществует несколько моделей управления ЖЦ ПО, каждая из которых подходит для определённых типов проектов:\n\n- **Водопадная модель (Waterfall)**\n  Линейная модель, в которой каждый этап завершается перед началом следующего. Подходит для проектов с чётко определёнными и стабильными требованиями. Недостаток — низкая гибкость: изменения на поздних этапах требуют возврата к предыдущим стадиям.\n\n- **Итеративная модель**\n  Разработка ведётся по циклам (итерациям), в каждой из которых реализуется часть функциональности. Позволяет постепенно уточнять требования и демонстрировать промежуточные результаты.\n\n- **Спиральная модель**\n  Сочетает итеративный подход с элементами управления рисками. Каждый виток спирали включает планирование, анализ рисков, разработку и оценку. Подходит для крупных и сложных проектов с высокой неопределённостью.\n\n- **Agile (гибкая модель)**\n  Основана на итеративной и инкрементальной разработке с активным вовлечением заказчика. Agile-методологии (например, Scrum, Kanban) делают акцент на быстрой адаптации к изменениям, постоянной обратной связи и доставке рабочего ПО небольшими порциями.\n\n### Важность системного подхода\n\nСистемный подход предполагает рассмотрение ПО как целостной системы, где все компоненты взаимосвязаны. Он помогает:\n\n- Учитывать влияние всех факторов (технических, организационных, человеческих).\n- Избегать узких мест и противоречий на этапе проектирования.\n- Обеспечивать согласованность между требованиями, архитектурой и реализацией.\n\nИгнорирование системного подхода ведёт к фрагментарному восприятию проекта, что увеличивает риск ошибок, перерасхода бюджета и несоответствия конечного продукта ожиданиям заказчика.\n\n### Почему игнорирование этапов ведёт к провалу проектов\n\nМногие провалы IT-проектов (например, Healthcare.gov в 2013 году, проект NHS IT в Великобритании) связаны с пропуском или поверхностным выполнением ключевых этапов ЖЦ ПО:\n\n- **Недостаточный анализ требований** → система не решает реальные задачи пользователей.\n- **Отсутствие тестирования** → высокий уровень ошибок в продакшене.\n- **Слабое управление изменениями** → «расползание объёма» (scope creep) и срыв сроков.\n- **Игнорирование сопровождения** → накопление технического долга и невозможность дальнейшего развития.\n\nСоблюдение этапов жизненного цикла, выбор подходящей модели и применение системного мышления позволяют минимизировать риски и повысить вероятность успеха проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Типы требований: функциональные и нефункциональные\n\nПри разработке программного обеспечения ключевым этапом является корректное определение и документирование требований. Требования делятся на два основных типа: **функциональные** и **нефункциональные**. Понимание различий между ними и их качественная спецификация напрямую влияют на успех проекта.\n\n#### Функциональные требования\n\nФункциональные требования описывают, **что** должна делать система. Они определяют поведение программного обеспечения в ответ на определённые действия пользователя или внешние события.\n\n**Примеры функциональных требований:**\n- Пользователь может зарегистрироваться в системе, введя email и пароль.\n- Система должна отправлять уведомление по электронной почте при изменении статуса заказа.\n- Администратор может просматривать и редактировать данные пользователей.\n\nЭти требования часто формулируются в виде пользовательских историй (user stories) или описываются с помощью диаграмм вариантов использования (Use Case Diagrams) в UML.\n\n#### Нефункциональные требования\n\nНефункциональные требования определяют **как** система должна работать. Они описывают характеристики производительности, безопасности, надёжности, удобства использования и другие атрибуты качества.\n\n**Примеры нефункциональных требований:**\n- Система должна обрабатывать не менее 1000 запросов в секунду.\n- Время отклика интерфейса не должно превышать 2 секунд при нормальной нагрузке.\n- Все передаваемые данные должны шифроваться с использованием TLS 1.2 или выше.\n- Интерфейс должен быть доступен для пользователей с ограниченными возможностями (соответствие WCAG 2.1).\n\nЭти требования часто упускаются на начальных этапах, но их игнорирование может привести к критическим сбоям.\n\n### Реальные кейсы провалов проектов из-за плохой спецификации требований\n\n#### 1. **Провал системы IRS (Налоговая служба США, 2000-е годы)**\n\n**Проблема:** Проект модернизации налоговой системы США затянулся на десятилетие и обошёлся в миллиарды долларов. Одной из главных причин стал **недостаточный анализ и документирование требований**.\n\n**Детали:**\n- Функциональные требования постоянно менялись из-за отсутствия чёткого взаимодействия с заинтересованными сторонами.\n- Не были учтены нефункциональные требования по производительности и масштабируемости.\n- В результате система не справлялась с нагрузкой во время налоговой кампании.\n\n**Вывод:** Отсутствие стабильной базы требований и игнорирование нефункциональных аспектов привело к техническому долгу, перерасходу бюджета и потере доверия.\n\n#### 2. **Провал проекта Healthcare.gov (США, 2013)**\n\n**Проблема:** При запуске федерального портала здравоохранения сайт не работал более чем у 80% пользователей.\n\n**Причины, связанные с требованиями:**\n- Не были определены точные функциональные требования для интеграции с различными страховыми компаниями.\n- Отсутствовали чёткие нефункциональные требования по нагрузке: система не была протестирована на пиковой нагрузке.\n- Не было реализовано резервное копирование и отказоустойчивость.\n\n**Результат:** Пользователи не могли зарегистрироваться, данные терялись, политический скандал. На устранение проблем ушли месяцы и сотни миллионов долларов.\n\n#### 3. **Провал системы Knight Capital (2012)**\n\n**Проблема:** Из-за ошибки в программном обеспечении компания потеряла **440 миллионов долларов за 45 минут**.\n\n**Связь с требованиями:**\n- В систему была внедрена новая функция (алгоритмическая торговля), но **не были задокументированы функциональные ограничения** и сценарии деактивации.\n- Отсутствовали нефункциональные требования по тестированию в продакшене и мониторингу.\n- Устаревший код был активирован по ошибке, что привело к неконтролируемым сделкам.\n\n**Вывод:** Даже в высокотехнологичных компаниях игнорирование требований к безопасности, тестированию и откату изменений может привести к катастрофическим последствиям.\n\n### Заключение\n\nКачественная спецификация требований — это не формальность, а основа успешного проекта. Функциональные требования определяют, что делает система, а нефункциональные — насколько хорошо она это делает. Провалы реальных проектов показывают, что пренебрежение любым из типов требований может привести к техническим, финансовым и репутационным потерям.\n\n**Рекомендации:**\n- Вовлекайте всех заинтересованных сторон на этапе анализа.\n- Документируйте и верифицируйте как функциональные, так и нефункциональные требования.\n- Используйте стандарты (например, UML, IEEE 830) для формализации.\n- Проводите регулярные ревью требований."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Методы сбора требований\n\nСбор требований — это ключевой этап на начальной фазе жизненного цикла разработки программного обеспечения. От качества собранной информации зависит успех всего проекта. Существует несколько проверенных методов выявления потребностей пользователей и заинтересованных сторон.\n\n### Основные методы сбора требований\n\n#### 1. Интервью\nИнтервью — один из самых эффективных способов получения глубокого понимания потребностей заказчика. Проводится в формате личной беседы (очно или удалённо) между аналитиком и представителем бизнеса или конечным пользователем.\n\n**Преимущества:**\n- Возможность задавать уточняющие вопросы в реальном времени.\n- Высокая точность интерпретации ответов.\n- Установление доверительных отношений с заинтересованными сторонами.\n\n**Недостатки:**\n- Трудоёмкость и временные затраты.\n- Риск субъективности интерпретации.\n- Ограниченное количество участников.\n\n**Рекомендации:**\n- Подготавливать структурированный список вопросов заранее.\n- Проводить интервью с представителями разных ролей (менеджеры, пользователи, технические специалисты).\n- Фиксировать результаты в протоколе с последующим согласованием у участников.\n\n#### 2. Анкетирование\nАнкетирование предполагает сбор информации с помощью стандартизированных вопросов, распространяемых среди большой группы пользователей.\n\n**Преимущества:**\n- Возможность охватить большое количество респондентов.\n- Сравнимость и количественная оценка ответов.\n- Экономия времени при массовом опросе.\n\n**Недостатки:**\n- Ограниченная глубина ответов.\n- Низкий процент возврата анкет.\n- Сложность формулировки универсальных вопросов.\n\n**Рекомендации:**\n- Использовать смешанный тип вопросов (закрытые, открытые, шкалы).\n- Проводить пилотное тестирование анкеты.\n- Обеспечивать анонимность для получения более честных ответов.\n\n#### 3. Наблюдение\nМетод заключается в прямом наблюдении за процессами, которые выполняют пользователи в реальных условиях.\n\n**Преимущества:**\n- Выявление скрытых или неосознанных потребностей.\n- Понимание реальных рабочих процессов, а не описанных в теории.\n- Обнаружение узких мест и неэффективных операций.\n\n**Недостатки:**\n- Высокие временные затраты.\n- Возможное искажение поведения пользователей из-за присутствия наблюдателя (эффект Хоторна).\n- Требует навыков качественного анализа.\n\n**Рекомендации:**\n- Использовать видеозапись (с согласия пользователей) для последующего анализа.\n- Комбинировать с интервью для уточнения наблюдений.\n- Документировать процессы в виде диаграмм потоков данных или use-case.\n\n#### 4. Анализ документации\nМетод включает изучение существующих документов: регламентов, инструкций, отчётов, технических спецификаций, описаний бизнес-процессов.\n\n**Преимущества:**\n- Доступность информации без привлечения людей.\n- Возможность понять формализованные процессы.\n- Основа для выявления противоречий между документами и реальной практикой.\n\n**Недостатки:**\n- Документы могут быть устаревшими или неполными.\n- Не отражают неформальные практики.\n- Требует времени на обработку большого объёма текста.\n\n**Рекомендации:**\n- Проверять актуальность документов.\n- Сравнивать документацию с реальными процессами (например, через наблюдение).\n- Использовать методы извлечения требований (например, выделение сущностей, действий, условий).\n\n## Работа с заинтересованными сторонами (stakeholders)\n\n**Заинтересованные стороны** — это все лица или группы, которые прямо или косвенно влияют на проект или подвержены его влиянию. К ним относятся:\n- Заказчики и спонсоры проекта\n- Конечные пользователи\n- Менеджеры и руководители подразделений\n- Технические специалисты (разработчики, администраторы)\n- Внешние регуляторы и партнёры\n\n### Этапы работы со stakeholder’ами\n\n1. **Идентификация** — составление полного списка всех заинтересованных сторон.\n2. **Анализ влияния и интереса** — оценка уровня влияния и заинтересованности каждой стороны (часто используется матрица влияние/интерес).\n3. **Планирование взаимодействия** — определение частоты, формата и содержания коммуникации с каждой группой.\n4. **Вовлечение** — активное включение stakeholder’ов в процессы сбора требований, согласования решений, тестирования.\n5. **Мониторинг и обратная связь** — постоянное отслеживание изменений в интересах и ожиданиях.\n\n### Проблемы при работе с заинтересованными сторонами\n- Противоречивые требования от разных групп.\n- Недостаточная доступность ключевых лиц.\n- Неспособность заказчика чётко сформулировать свои потребности.\n- Изменение требований в ходе проекта.\n\n### Лучшие практики\n- Регулярные встречи с ключевыми stakeholder’ами.\n- Использование прототипов и wireframe’ов для визуализации требований.\n- Ведение реестра требований (requirements traceability matrix) для отслеживания источника и статуса каждого требования.\n- Подтверждение требований в письменной форме (согласование и подпись).\n\n> **Важно:** Успешный проект — это не только техническое решение, но и результат эффективного взаимодействия с людьми. Умение слушать, задавать правильные вопросы и находить компромиссы между различными интересами — ключевые навыки системного аналитика."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Формализация требований: пользовательские истории (User Stories), шаблон \"Как пользователь, я хочу…\", критерии принятия (acceptance criteria)\n\nПри разработке программного обеспечения важнейшим этапом является точное и понятное формулирование требований. Одним из наиболее эффективных и широко используемых подходов к формализации функциональных требований в гибких методологиях разработки (например, Scrum, Extreme Programming) является **пользовательская история (User Story)**.\n\n#### Что такое пользовательская история?\n\n**Пользовательская история** — это краткое, простое описание функциональности системы с точки зрения конечного пользователя. Она фокусируется на **ценности**, которую получает пользователь от реализации этой функции, а не на технических деталях её реализации.\n\nПользовательские истории помогают:\n- Лучше понять потребности пользователей;\n- Обеспечить коммуникацию между разработчиками, заказчиками и аналитиками;\n- Разбить сложные функции на управляемые части;\n- Оценить трудозатраты и планировать итерации.\n\n#### Шаблон: \"Как пользователь, я хочу…\"\n\nДля стандартизации формулировок используется универсальный шаблон:\n\n> **\"Как [роль], я хочу [цель/функция], чтобы [бизнес-ценность/причина]\"**\n\nПримеры:\n- *Как пользователь, я хочу войти в систему с помощью email и пароля, чтобы получить доступ к своему личному кабинету.*\n- *Как администратор, я хочу видеть список всех зарегистрированных пользователей, чтобы контролировать активность на платформе.*\n- *Как гость, я хочу восстановить пароль по email, чтобы восстановить доступ к аккаунту.*\n\nЭтот шаблон помогает чётко определить:\n- **Кто** — роль пользователя (например, «пользователь», «администратор», «гость»);\n- **Что** — желаемая функция;\n- **Зачем** — бизнес-цель или ценность.\n\n#### Критерии принятия (Acceptance Criteria)\n\nПользовательская история сама по себе — это лишь начало. Чтобы избежать неоднозначностей и обеспечить согласованность между командой и заказчиком, к каждой истории формулируются **критерии принятия**.\n\n**Критерии принятия** — это конкретные условия, которые должны быть выполнены, чтобы история считалась завершённой и принятой заказчиком. Они описывают, *как проверить*, что функция работает корректно.\n\nКритерии формулируются в виде набора проверяемых условий, часто в формате **Given-When-Then** (в рамках BDD — Behavior-Driven Development):\n\n> **Given** — начальное состояние системы;\n> **When** — действие пользователя;\n> **Then** — ожидаемый результат.\n\n**Пример для истории:** *\"Как пользователь, я хочу войти в систему с помощью email и пароля, чтобы получить доступ к своему личному кабинету.\"\n\n**Критерии принятия:**\n1. Given: пользователь находится на странице входа\n   When: вводит корректный email и пароль\n   Then: перенаправляется в личный кабинет\n\n2. Given: пользователь вводит неверный пароль\n   When: нажимает кнопку \"Войти\"\n   Then: видит сообщение \"Неверный email или пароль\"\n\n3. Given: поля email и пароль пусты\n   When: нажимает кнопку \"Войти\"\n   Then: видит сообщение \"Поля обязательны для заполнения\"\n\n#### Преимущества использования пользовательских историй и критериев принятия\n- Упрощают коммуникацию в команде;\n- Снижают риск недопонимания требований;\n- Позволяют проводить автоматизированное тестирование;\n- Служат основой для планирования спринтов и оценки задач;\n- Фокусируют разработку на реальных потребностях пользователей.\n\n#### Заключение\nФормализация требований через пользовательские истории и критерии принятия — это не просто шаблоны, а мощный инструмент управления требованиями в современной разработке ПО. Он способствует созданию качественного, ориентированного на пользователя продукта и минимизирует риски ошибок на ранних этапах жизненного цикла."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение в UML: Диаграмма прецедентов (Use Case Diagram)\n\n**UML (Unified Modeling Language)** — это унифицированный язык визуального моделирования, широко используемый в разработке программного обеспечения для описания, проектирования и документирования систем. Одним из ключевых элементов UML является **диаграмма прецедентов (Use Case Diagram)**, которая позволяет наглядно представить функциональность системы с точки зрения её пользователей.\n\n#### Назначение диаграммы прецедентов\n\nДиаграмма прецедентов используется на этапе анализа требований для:\n- Определения границ системы;\n- Выявления взаимодействий между пользователями (акторами) и системой;\n- Описания функциональных возможностей системы;\n- Формирования общего понимания системы у всех заинтересованных сторон.\n\nОна не показывает последовательность действий или внутреннюю логику системы, а фокусируется на том, **что** система делает, а не **как**.\n\n#### Основные элементы диаграммы прецедентов\n\n1. **Актор (Actor)**\n   - Представляет роль пользователя или внешней системы, взаимодействующей с рассматриваемой системой.\n   - Акторы не обязательно являются людьми — это могут быть другие программные системы, устройства или таймеры.\n   - Обозначается иконкой человечка или именем внутри прямоугольника (в зависимости от нотации).\n   - Примеры: *Пользователь*, *Администратор*, *Платёжный шлюз*, *Система уведомлений*.\n\n2. **Прецедент (Use Case)**\n   - Описание определённой функции или поведения системы, которое предоставляет ценность актору.\n   - Представляет собой единицу функциональности, например: *Войти в систему*, *Сделать заказ*, *Получить отчёт*.\n   - Обозначается овалом с названием внутри.\n\n3. **Система (System Boundary)**\n   - Прямоугольник, обозначающий границы системы. Внутри него размещаются прецеденты, а акторы находятся снаружи.\n   - Помогает чётко определить, что входит в систему, а что является внешним окружением.\n\n#### Типы связей между элементами\n\n1. **Ассоциация (Association)**\n   - Прямая линия между актором и прецедентом.\n   - Показывает, что актор взаимодействует с данным прецедентом.\n   - Пример: *Пользователь* → *Войти в систему*.\n\n2. **Include (включение)**\n   - Обозначается пунктирной стрелкой с пометкой `<<include>>`.\n   - Указывает, что один прецедент обязательно включает в себя поведение другого.\n   - Используется для выделения общей функциональности, выносимой в отдельный прецедент.\n   - Пример: *Сделать заказ* включает *Проверить наличие товара*.\n\n3. **Extend (расширение)**\n   - Пунктирная стрелка с пометкой `<<extend>>`, направленная от расширяющего прецедента к расширяемому.\n   - Описывает опциональное или условное поведение, которое может добавляться к основному прецеденту.\n   - Пример: *Применить купон* может расширять *Оформить заказ*, если пользователь его предоставил.\n\n4. **Generalization (обобщение)**\n   - Используется как для акторов, так и для прецедентов.\n   - Показывает иерархию «родитель-потомок»: специализированный элемент наследует поведение обобщённого.\n   - Обозначается стрелкой с пустым треугольником.\n   - Пример: *Администратор* — это обобщение *Пользователя*; *Редактировать профиль* — обобщение *Просмотреть профиль*.\n\n#### Пример диаграммы (текстовое описание)\n\n```\n[Пользователь] -- (Войти в систему)\n[Пользователь] -- (Создать заказ)\n(Создать заказ) --> (Проверить наличие товара) : <<include>>\n(Создать заказ) <-- (Применить купон) : <<extend>>\n[Администратор] --|> [Пользователь]\n[Администратор] -- (Управление товарами)\n```\n\n#### Практическая польза\n\n- Помогает команде и заказчику договориться о функциональности системы.\n- Упрощает выявление недостающих или избыточных требований.\n- Служит основой для разработки сценариев тестирования и пользовательской документации.\n\nДиаграмма прецедентов — это мощный инструмент на начальных этапах жизненного цикла ПО, обеспечивающий ясность и согласованность в понимании требований."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "text",
          "code": "Пользовательская история:\n\nНазвание: Бронирование билета на мероприятие\n\nКак: Посетитель\nХочу: Возможность забронировать билет на мероприятие онлайн\nЧтобы: Убедиться, что место за мной зарезервировано и избежать очередей\n\nПриемочные критерии:\n1. Пользователь может просмотреть список доступных мероприятий.\n2. Пользователь может выбрать мероприятие и указать количество билетов.\n3. Система проверяет наличие билетов перед бронированием.\n4. После подтверждения бронирования пользователь получает уникальный код брони.\n5. Забронированные билеты временно резервируются (на 15 минут), после чего освобождаются при отсутствии оплаты.\n\n\nДиаграмма прецедентов (UML Use Case Diagram) — текстовое описание:\n\nАкторы:\n- Посетитель (неавторизованный пользователь)\n- Зарегистрированный пользователь\n- Администратор системы\n\nПрецеденты и связи:\n\n[Посетитель] -- (Просмотр списка мероприятий)\n[Посетитель] -- (Просмотр деталей мероприятия)\n[Посетитель] -- (Регистрация в системе)\n\n[Зарегистрированный пользователь] -- (Просмотр списка мероприятий)\n[Зарегистрированный пользователь] -- (Просмотр деталей мероприятия)\n[Зарегистрированный пользователь] -- (Выбор билетов)\n[Зарегистрированный пользователь] -- (Бронирование билетов)\n[Зарегистрированный пользователь] -- (Оплата билетов)\n[Зарегистрированный пользователь] -- (Просмотр истории бронирований)\n\n[Администратор] -- (Управление мероприятиями)\n[Администратор] -- (Добавление нового мероприятия)\n[Администратор] -- (Редактирование информации о мероприятии)\n[Администратор] -- (Просмотр отчетов по продажам)\n\nОтношения:\n- (Бронирование билетов) включает (Проверка наличия билетов)\n- (Оплата билетов) расширяет (Бронирование билетов) при успешной оплате\n- (Регистрация в системе) расширяет (Бронирование билетов) для неавторизованных пользователей\n\nПримечание: Все прецеденты, связанные с бронированием и оплатой, доступны только авторизованным пользователям. Неавторизованный пользователь может начать бронирование, но обязан зарегистрироваться или войти в систему до завершения процесса.\n\nПример визуального представления (в виде псевдокода диаграммы):\n\n+---------------------+\n|   Посетитель        |\n+----------+----------+\n           |\n           | (включает)\n           v\n+---------------------+\n| Просмотр мероприятий |\n+---------------------+\n           |\n           | (расширяет)\n           v\n+---------------------+\n| Регистрация / Вход  |\n+---------------------+\n           |\n           v\n+---------------------+\n| Выбор и бронирование |\n|      билетов        |\n+----------+----------+\n           |\n           | (включает)\n           v\n+---------------------+\n| Проверка наличия    |\n+----------+----------+\n           |\n           | (расширяет)\n           v\n+---------------------+\n|     Оплата билетов  |\n+---------------------+\n\n+---------------------+\n|   Администратор     |\n+----------+----------+\n           |\n           v\n+-----------------------------+\n| Управление мероприятиями    |\n| (добавление, редактирование) |\n+-----------------------------+\n           |\n           v\n+---------------------+\n| Просмотр отчетов    |\n+---------------------+\n\nЭтот пример демонстрирует, как пользовательские истории и диаграммы прецедентов работают вместе для формализации функциональных требований системы бронирования билетов.",
          "explanation": "Пример демонстрирует связь между пользовательской историей (Agile-подход) и диаграммой прецедентов (UML), что позволяет комплексно описать функциональные требования к системе. Такой подход соответствует целям модуля: формализация требований с использованием стандартизированных методов (UML и пользовательские истории)."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Практическое задание: Анализ требований на основе интервью с заказчиком\n\n#### Кейс-описание: Система управления онлайн-библиотекой\n\nВы — аналитик в команде разработки программного обеспечения. Ваша задача — создать систему управления онлайн-библиотекой, которая позволит пользователям:\n\n- Просматривать каталог книг;\n- Выполнять поиск по названию, автору, жанру;\n- Бронировать и брать книги в электронную аренду;\n- Возвращать книги до окончания срока аренды;\n- Получать уведомления о скором окончании срока аренды;\n- Оставлять отзывы и оценки книгам.\n\nАдминистраторы системы должны иметь возможность:\n\n- Добавлять, редактировать и удалять книги;\n- Управлять учетными записями пользователей;\n- Просматривать статистику по аренде книг;\n- Получать отчеты о задолженностях (просроченная аренда).\n\nСистема должна быть веб-ориентированной, с поддержкой мобильных устройств. Проект должен быть завершён за 6 месяцев. Бюджет ограничен.\n\n---\n\n#### Задание\n\n1. **Проведите воображаемое интервью с заказчиком** (на основе кейса):\n   - Составьте список из 8–10 вопросов, которые вы задали бы заказчику для уточнения требований.\n   - Примеры вопросов:\n     - Какие категории пользователей выделяются в системе?\n     - Какой срок аренды книги по умолчанию?\n     - Должна ли система поддерживать продление аренды?\n     - Какие форматы книг будут поддерживаться (PDF, EPUB и т.д.)?\n     - Нужна ли регистрация через социальные сети?\n     - Какие требования к безопасности (например, шифрование данных)?\n\n2. **Выделите требования**:\n   - Разделите выявленные требования на **функциональные** и **нефункциональные**.\n   - Пример функционального требования: «Пользователь может искать книги по автору».\n   - Пример нефункционального требования: «Система должна отвечать на запрос поиска не более чем за 2 секунды».\n\n3. **Оформите требования в виде пользовательских историй**:\n   Используйте шаблон: \n   > *«Как [роль], я хочу [действие], чтобы [цель]»*\n\n   Пример:\n   > *«Как читатель, я хочу искать книги по жанру, чтобы быстрее находить интересующие меня произведения»*\n\n   Оформите не менее 6 пользовательских историй (минимум 2 для администратора).\n\n4. **Постройте Use Case-диаграмму**:\n   - Используя нотацию UML, создайте диаграмму прецедентов.\n   - Укажите акторов (например, «Читатель», «Администратор»).\n   - Добавьте прецеденты (use cases), соответствующие выявленным функциям.\n   - Покажите связи: ассоциации, «include», «extend» при необходимости.\n\n   Примеры прецедентов:\n   - «Зарегистрироваться в системе»\n   - «Найти книгу»\n   - «Взять книгу в аренду»\n   - «Удалить книгу из каталога»\n\n---\n\n#### Рекомендации по выполнению\n\n- Используйте инструменты для построения диаграмм: draw.io, Lucidchart, StarUML, или любые другие.\n- Пользовательские истории должны быть краткими, понятными и ориентированными на ценность для пользователя.\n- Use Case-диаграмма должна быть читаемой и соответствовать стандартам UML.\n- Обоснуйте выбор выделенных требований, особенно нефункциональных (производительность, безопасность, удобство использования и т.д.).\n\n---\n\n#### Цель задания\n\n- На практике применить навыки выявления и анализа требований.\n- Научиться переводить потребности заказчика в формализованные модели.\n- Подготовиться к следующему этапу — проектированию архитектуры системы.\n\nВыполненное задание поможет вам понять, как даже небольшие упущения на этапе анализа могут привести к серьёзным проблемам в дальнейшем — например, к превышению бюджета, срыву сроков или неудовлетворённости пользователей."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Рецензирование и итерации: как уточнять требования, работать с изменениями, избегать неоднозначностей\n\nНа этапе анализа и формализации требований к программному обеспечению крайне важно не только собрать исходную информацию, но и систематически её уточнять, проверять и корректировать. Процессы **рецензирования** и **итераций** играют ключевую роль в обеспечении качества требований и предотвращении критических ошибок на последующих этапах жизненного цикла ПО.\n\n#### 1. Рецензирование требований\n\nРецензирование — это процесс систематической проверки документированных требований с целью выявления ошибок, неоднозначностей, противоречий и пробелов. Оно может проводиться как формально (например, в виде инспекций), так и неформально (через обсуждения с заинтересованными сторонами).\n\n**Цели рецензирования:**\n- Обеспечение полноты требований (все необходимые функции и ограничения учтены).\n- Проверка корректности (требования точно отражают нужды пользователей).\n- Выявление неоднозначностей (например, использование расплывчатых терминов вроде \"быстро\", \"удобно\").\n- Обнаружение противоречий между требованиями.\n- Проверка реализуемости и измеримости (особенно важно для нефункциональных требований).\n\n**Участники рецензирования:**\n- Аналитики и разработчики.\n- Представители бизнеса и конечные пользователи.\n- Тестировщики (для оценки тестируемости требований).\n- Архитекторы (для оценки соответствия системным ограничениям).\n\n#### 2. Итерации в уточнении требований\n\nВ гибких методологиях разработки (например, Scrum, Extreme Programming) требования не фиксируются раз и навсегда, а **эволюционируют** в ходе итераций. Каждая итерация включает:\n- Уточнение существующих требований.\n- Добавление новых.\n- Отказ от нерелевантных или избыточных.\n\n**Преимущества итеративного подхода:**\n- Возможность адаптироваться к изменяющимся потребностям бизнеса.\n- Раннее выявление ошибок в понимании требований.\n- Постепенное наращивание точности и детализации.\n- Получение обратной связи от пользователей на ранних этапах.\n\n#### 3. Работа с изменениями требований\n\nИзменения неизбежны. Однако важно управлять ими системно:\n\n- **Контроль изменений (Change Management):** все изменения должны проходить через формализованный процесс — подача запроса, оценка влияния, утверждение, внедрение.\n- **Оценка воздействия (Impact Analysis):** перед внесением изменения анализируется его влияние на архитектуру, сроки, стоимость и другие требования.\n- **Версионирование требований:** использование систем контроля версий (например, в инструментах вроде Jira, Confluence, DOORS) позволяет отслеживать историю изменений.\n\n#### 4. Как избежать неоднозначностей\n\nНеоднозначности — одна из главных причин провалов IT-проектов. Способы борьбы с ними:\n\n- **Использование стандартизированных шаблонов:** например, пользовательские истории по формату \"Как [роль], я хочу [действие], чтобы [цель]\".\n- **Формализация с помощью UML:** диаграммы прецедентов, диаграммы классов и состояний помогают визуализировать поведение системы.\n- **Глоссарий терминов:** единый словарь, согласованный со всеми заинтересованными сторонами, исключает разночтения.\n- **Примеры и сценарии использования:** конкретные примеры поведения системы (например, в формате Gherkin: Given-When-Then) делают требования более понятными.\n\n#### Заключение\n\nЭффективное управление требованиями — это не разовый процесс, а непрерывная работа по уточнению, проверке и адаптации. Регулярное рецензирование и итеративный подход позволяют создавать точные, полные и реализуемые требования, что напрямую влияет на успех всего проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение в документирование: структура спецификации требований (SRS), связь с ГОСТ и современными практиками\n\nДокументирование требований — один из ключевых этапов в жизненном цикле разработки программного обеспечения (ПО). Оно обеспечивает чёткое понимание того, что должно быть создано, и служит основой для проектирования, реализации, тестирования и сопровождения системы. Центральным документом на этом этапе является **Спецификация требований к программному обеспечению (Software Requirements Specification, SRS)**.\n\n#### Что такое SRS?\n\nSRS — это формализованный документ, описывающий **функциональные** и **нефункциональные требования** к системе, а также её поведение в различных условиях. Он служит связующим звеном между заказчиком, аналитиком, разработчиками и тестировщиками, минимизируя недопонимание и снижая риск ошибок.\n\nОсновные цели SRS:\n- Чётко определить, что система должна делать.\n- Служить основой для оценки стоимости, сроков и рисков.\n- Обеспечить базу для тестирования и верификации.\n- Способствовать управлению изменениями требований.\n\n#### Типовая структура SRS\n\nХотя структура может варьироваться в зависимости от проекта и методологии, стандарт IEEE 830 (рекомендованный для SRS) предлагает следующую организацию:\n\n1. **Введение**\n   - Цель документа\n   - Область применения\n   - Определения, сокращения, аббревиатуры\n   - Ссылки\n   - Обзор документа\n\n2. **Общее описание**\n   - Перспектива системы (как она вписывается в более широкую экосистему)\n   - Функциональность\n   - Пользовательские характеристики\n   - Ограничения\n   - Предположения и зависимости\n\n3. **Специфические требования**\n   - Функциональные требования (что система должна делать)\n   - Нефункциональные требования (производительность, безопасность, удобство использования и т.д.)\n   - Интерфейсы (пользовательские, программные, аппаратные)\n   - Требования к данным\n   - Требования к надёжности и доступности\n\n4. **Приложения (опционально)**\n   - Диаграммы, прототипы, глоссарий\n\n#### Связь с ГОСТ\n\nВ российской практике разработки ПО активно используются **стандарты ГОСТ**, регулирующие документирование. Наиболее релевантными являются:\n\n- **ГОСТ 34.601-90** — «Автоматизированные системы. Стадии разработки» — определяет этапы создания АС, включая стадию «Формирование требований».\n- **ГОСТ 19.101-77** — «Единая система программной документации (ЕСПД). Виды программ и программных документов» — задаёт классификацию и состав документации.\n- **ГОСТ 19.201-78** — «Техническое задание на разработку программных средств» — близок по назначению к SRS.\n\n**Техническое задание (ТЗ)** по ГОСТ 19.201-78 включает:\n- Назначение и цели разработки\n- Требования к программе\n- Требования к функциональным характеристикам\n- Требования к надёжности\n- Условия эксплуатации\n- Технико-экономические показатели\n\nТаким образом, **SRS можно рассматривать как международный аналог ТЗ**, адаптированный под современные практики управления требованиями.\n\n#### Современные практики\n\nХотя формальные документы вроде SRS и ТЗ остаются важными, особенно в регулируемых отраслях (медицина, финансы, оборона), в agile-средах предпочтение отдаётся **гибким и итеративным подходам**:\n\n- **Пользовательские истории (User Stories)** — краткие описания функциональности с точки зрения пользователя (например: «Как пользователь, я хочу войти в систему, чтобы получить доступ к своим данным»).\n- **Акцептанс-критерии** — условия, при которых история считается выполненной.\n- **Прототипы и wireframes** — визуализация интерфейсов для уточнения требований.\n- **Backlog продукта** — динамический список требований, управляемый Product Owner.\n\nОднако и в agile-проектах **SRS или его элементы могут использоваться** для критически важных систем, где требуется строгая документация и аудит.\n\n#### Заключение\n\nДокументирование требований — это не формальность, а **основа успешного проекта**. Понимание структуры SRS, его соответствия ГОСТ и интеграции с современными практиками позволяет аналитикам и разработчикам создавать качественные, предсказуемые и поддерживаемые системы. Выбор между формальным SRS и гибкими практиками зависит от масштаба проекта, отрасли, уровня регулирования и команды, но глубокое понимание обоих подходов — обязательный навык современного специалиста в области ПО."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 1: Основы жизненного цикла ПО и анализ требований",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Объясните, почему этап анализа требований считается одним из самых критичных в жизненном цикле разработки программного обеспечения. Приведите не менее трёх аргументов, опираясь на возможные последствия некачественного анализа (например, срыв сроков, превышение бюджета, неудовлетворённость пользователей). Какие практики (например, рецензирование, итерации, использование UML) помогают минимизировать риски на этом этапе? Обоснуйте свой ответ.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "На основе кейса «Система управления онлайн-библиотекой» выделите пять функциональных и три нефункциональных требования. Для каждого функционального требования укажите, какая роль (актор) его инициирует, и кратко опишите сценарий его выполнения. Для нефункциональных требований обоснуйте их важность — например, почему производительность поиска должна быть не более 2 секунд или зачем нужна адаптивность под мобильные устройства.",
            "options": [],
            "correct_answers": [],
            "points": 25
          },
          {
            "text": "Оформите следующие возможности системы онлайн-библиотеки в виде пользовательских историй, используя шаблон: «Как [роль], я хочу [действие], чтобы [цель]». Создайте не менее шести историй (минимум две для администратора). Для каждой истории сформулируйте не менее двух приёмочных критериев, которые позволят проверить, выполнена ли история. Пример: «Как читатель, я хочу продлить аренду книги, чтобы продолжить чтение без повторного бронирования».",
            "options": [],
            "correct_answers": [],
            "points": 25
          },
          {
            "text": "Опишите, как вы построили бы Use Case-диаграмму (диаграмму прецедентов) для системы онлайн-библиотеки. Перечислите акторов и основные прецеденты. Укажите, какие отношения (ассоциации, include, extend) вы бы использовали и почему. Приведите минимум один пример использования «include» и один — «extend», объяснив их смысл в контексте системы. Например: «Прецедент „Взять книгу в аренду“ включает „Проверка наличия книги“». Как такая диаграмма помогает команде разработки и заказчику лучше понять систему?",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Сравните подходы к документированию требований по ГОСТ (например, Техническое задание по ГОСТ 19.201-78) и современные практики (например, SRS по IEEE 830, пользовательские истории в Agile). В чём их основные различия? В каких типах проектов предпочтительнее использовать формальный документ вроде ТЗ, а в каких — гибкие практики? Приведите по одному примеру из реальной практики (например, разработка банковского приложения vs. стартап в сфере социальных сетей). Обоснуйте ваш выбор.",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    },
    {
      "id": "4fe244ba-d565-4ffe-9cad-e41fe3110063",
      "title": "Модуль 2: Проектирование ПО и UML-моделирование",
      "description": "В этом модуле студенты погружаются в процессы проектирования программного обеспечения и осваивают стандарты визуального моделирования с помощью UML. Акцент делается на формализацию требований, построение архитектуры системы и создание читаемых, стандартизированных моделей, которые становятся основой для разработки. Студенты учатся мыслить системно, видеть ПО не как набор кода, а как структурированную систему с чёткими интерфейсами, поведением и ограничениями. Модуль закладывает фундамент для дальнейшей работы в команде, управления сложностью и предотвращения типичных ошибок на этапе проектирования.",
      "learning_objectives": [
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Создать техническую документацию по ГОСТ и современным стандартам.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 2,
      "content_blocks": [
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Введение в проектирование ПО: зачем нужно моделирование и к чему ведёт его отсутствие\n\nПроектирование программного обеспечения — это ключевой этап разработки, на котором формируется архитектура системы, определяются её компоненты, взаимодействия между ними и поведение в различных сценариях. Одним из наиболее эффективных инструментов проектирования является **моделирование**, особенно с использованием стандартизированных подходов, таких как **UML (Unified Modeling Language)**.\n\n### Зачем нужно моделирование ПО?\n\nМоделирование выполняет несколько важных функций:\n\n1. **Визуализация системы** — позволяет команде разработчиков, аналитикам, тестировщикам и заказчикам видеть структуру и поведение системы до её реализации.\n2. **Формализация требований** — помогает выявить и уточнить как функциональные, так и нефункциональные требования.\n3. **Обнаружение ошибок на ранних этапах** — гораздо дешевле исправить ошибку в модели, чем в уже написанном коде.\n4. **Коммуникация в команде** — UML-диаграммы становятся общим языком между участниками проекта.\n5. **Документирование архитектуры** — модели служат основой для технической документации и дальнейшего сопровождения системы.\n\nОтсутствие моделирования часто приводит к хаотичной разработке, когда каждый разработчик понимает систему по-своему, что влечёт за собой дублирование кода, ошибки интеграции и трудности масштабирования.\n\n### Последствия отсутствия проектирования: реальные примеры провалов IT-проектов\n\n#### 1. **Провал запуска Healthcare.gov (2013, США)**\n\nСайт Healthcare.gov был разработан для реализации реформы здравоохранения Обамы. При запуске сайт практически не работал: пользователи не могли зарегистрироваться, система падала под нагрузкой.\n\n**Причины провала**:\n- Отсутствие чёткого архитектурного проектирования.\n- Недостаточное моделирование потоков данных и взаимодействия между подсистемами.\n- Разработка велась без единой UML-модели, что привело к путанице между подрядчиками.\n\n**Последствия**: миллионы долларов убытков, политический скандал, срочный ввод команды из Google и Amazon для спасения проекта.\n\n#### 2. **Авария ракеты Ariane 5 (1996)**\n\nРакета Ariane 5 взорвалась через 40 секунд после старта. Причиной стал программный сбой в системе наведения.\n\n**Причины**:\n- Код от Ariane 4 был перенесён без адекватного анализа и моделирования поведения в новых условиях.\n- Не было проведено моделирование крайних сценариев (edge cases), включая более высокую скорость Ariane 5.\n- Отсутствие диаграмм последовательности и анализа потоков данных привело к неправильной обработке переполнения переменной.\n\n**Последствия**: потеря ракеты и спутников на сумму более $370 млн.\n\n#### 3. **Провал проекта FBI Virtual Case File (VCF)**\n\nПроект VCF был инициирован для модернизации систем учёта дел ФБР. Проект был свёрнут в 2005 году после потери **$170 млн**.\n\n**Причины**:\n- Отсутствие чётких требований и их формализации.\n- Никаких UML-диаграмм, use case или моделей архитектуры не было создано.\n- Разработка шла без контроля, с постоянными изменениями требований.\n\n**Вывод**: без проектирования невозможно управлять сложностью, а значит, невозможно гарантировать успех проекта.\n\n### Заключение\n\nПроектирование ПО — это не формальность, а необходимость. Моделирование с помощью UML позволяет избежать катастрофических ошибок, снизить риски и создавать надёжные, масштабируемые и поддерживаемые системы. Как говорят в индустрии: *\"Если вы не проектируете, вы проектируете на провал\".*"
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Жизненный цикл программного обеспечения: каскадная модель, итеративная разработка, Agile. Место проектирования в разных подходах\n\nЖизненный цикл программного обеспечения (ЖЦ ПО) — это структурированный процесс, охватывающий все этапы создания и сопровождения программного продукта: от формулировки требований до вывода из эксплуатации. Разные модели ЖЦ ПО определяют порядок выполнения этих этапов и подход к управлению проектом. Наиболее известные из них — каскадная модель, итеративная разработка и Agile. Каждая из них по-разному включает этап проектирования, что напрямую влияет на гибкость, предсказуемость и качество конечного продукта.\n\n#### 1. Каскадная модель (Waterfall)\n\n**Описание:**\nКаскадная модель — одна из первых и наиболее строгих моделей жизненного цикла. Она предполагает последовательное выполнение этапов:\n\n1. Анализ требований\n2. Проектирование\n3. Реализация (разработка)\n4. Тестирование\n5. Внедрение\n6. Сопровождение\n\nКаждый этап начинается только после полного завершения предыдущего. Модель получила название \"каскад\" из-за визуального сходства с водопадом — поток работ движется строго вниз.\n\n**Место проектирования:**\nПроектирование в каскадной модели — центральный и критически важный этап, следующий сразу за анализом требований. На этом этапе создаётся полная архитектура системы: определяются модули, интерфейсы, структура данных, выбираются технологии. Проектирование проводится **один раз и полностью** до начала кодирования.\n\n**Преимущества:**\n- Чёткая документация\n- Простота управления\n- Подходит для проектов с фиксированными и стабильными требованиями\n\n**Недостатки:**\n- Низкая гибкость: изменения требований на поздних этапах очень дороги\n- Позднее выявление ошибок\n- Конечный продукт доступен только в конце цикла\n\n**Применение:**\nКаскадная модель эффективна в проектах с высокими требованиями к безопасности и надёжности (например, в аэрокосмической, оборонной или медицинской отраслях), где изменения на поздних этапах недопустимы.\n\n---\n\n#### 2. Итеративная разработка (Iterative Development)\n\n**Описание:**\nИтеративная модель предполагает постепенное наращивание функциональности продукта через повторяющиеся циклы (итерации). Каждая итерация включает все этапы ЖЦ ПО (анализ, проектирование, реализация, тестирование), но охватывает только часть функциональности.\n\n**Место проектирования:**\nПроектирование проводится **на каждой итерации**, но имеет два уровня:\n- **Высокоуровневое архитектурное проектирование** — выполняется на ранних итерациях и определяет общую структуру системы.\n- **Детальное проектирование** — уточняется и расширяется на каждой итерации по мере добавления новых компонентов.\n\nТакой подход позволяет корректировать архитектуру на основе полученного опыта и обратной связи.\n\n**Преимущества:**\n- Ранняя демонстрация рабочего продукта\n- Возможность адаптации к изменениям\n- Постепенное уточнение требований и дизайна\n\n**Недостатки:**\n- Требует более сложного управления\n- Риск нестабильности архитектуры при плохом планировании\n\n**Примеры:**\nМодель Rational Unified Process (RUP) — яркий пример итеративного подхода, где проект делится на фазы (начало, разработка, построение, внедрение), каждая из которых содержит итерации.\n\n---\n\n#### 3. Agile (гибкая разработка)\n\n**Описание:**\nAgile — это не одна модель, а набор методологий (Scrum, Kanban, XP и др.), объединённых ценностями, описанными в [Манифесте Agile](https://agilemanifesto.org/). Основной принцип — **адаптивность, приоритет над функциональным ПО, тесное взаимодействие с заказчиком и готовность к изменениям**.\n\nAgile предполагает короткие итерации (спринты), на которых команда реализует небольшие, завершённые функции.\n\n**Место проектирования:**\nВ Agile проектирование:\n- **Непрерывно** — происходит на протяжении всего проекта.\n- **Эволюционно** — архитектура растёт вместе с продуктом (часто говорят о *emergent design* — проектировании, которое «проявляется»).\n- **Коллективно** — участвует вся команда, а не только архитекторы.\n\nПри этом проектирование не исключает предварительного планирования (upfront design), но оно минимально и фокусируется на ключевых рисках.\n\n**Преимущества:**\n- Высокая адаптивность к изменениям\n- Регулярная обратная связь от заказчика\n- Быстрое выявление и исправление ошибок\n\n**Недостатки:**\n- Сложность масштабирования\n- Зависимость от компетентности команды\n- Меньшая предсказуемость сроков и бюджета\n\n**Применение:**\nAgile идеально подходит для проектов с нестабильными или плохо определёнными требованиями, например, в стартапах или цифровых продуктах.\n\n---\n\n### Сравнение подходов по роли проектирования\n\n| Критерий | Каскадная модель | Итеративная разработка | Agile |\n|---------|------------------|------------------------|-------|\n| **Время проектирования** | Один раз, в начале | На каждой итерации | Постоянно, на протяжении проекта |\n| **Объём проектирования** | Полный, детальный | Поэтапное уточнение | Минимальное, эволюционное |\n| **Гибкость изменений** | Низкая | Средняя | Высокая |\n| **Риск ошибок в архитектуре** | Высокий (ошибки выявляются поздно) | Умеренный | Низкий (коррекция в процессе) |\n| **Документация** | Высокая | Средняя | Минимальная, только необходимая |\n\n---\n\n### Заключение\n\nВыбор модели жизненного цикла напрямую влияет на то, **как и когда** выполняется проектирование ПО. В каскадной модели проектирование — это фундамент, заложенный один раз и неизменный. В итеративной — это процесс постепенного уточнения архитектуры. В Agile проектирование становится органичной частью разработки, адаптирующейся к изменениям.\n\nПонимание этих различий позволяет грамотно выбирать подход в зависимости от характера проекта, стабильности требований, уровня рисков и команды. В современной практике часто используется **гибридный подход**, сочетающий строгость проектирования с гибкостью Agile — например, *Agile с элементами архитектурного надзора* (Agile with architectural runway)."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Требования к системе: функциональные и нефункциональные. Методы сбора, анализа и документирования\n\nПри проектировании программного обеспечения одним из ключевых этапов является **формирование и управление требованиями** — это основа, на которой строится вся последующая архитектура и реализация системы. Требования определяют, *что* должна делать система и *как* она должна это делать. Они делятся на два основных типа: **функциональные** и **нефункциональные**.\n\n#### Функциональные требования\n\nФункциональные требования описывают **поведение системы** — то, какие действия она должна выполнять, как реагировать на входные данные и какие результаты выдавать. Они отвечают на вопрос: *«Что система должна делать?»*\n\n**Примеры функциональных требований:**\n- Пользователь может авторизоваться в системе по логину и паролю.\n- Система должна сохранять заказы пользователей в базе данных.\n- Администратор может удалять учетные записи пользователей.\n\nФункциональные требования часто формулируются в виде:\n- **Пользовательских историй (User Stories)** — кратких описаний функциональности с точки зрения пользователя (например: «Как пользователь, я хочу войти в систему, чтобы получить доступ к своим данным»).\n- **Use Case (диаграмм вариантов использования)** — визуального представления взаимодействия акторов (пользователей, внешних систем) с системой.\n\n#### Нефункциональные требования\n\nНефункциональные требования определяют **качественные характеристики системы** — то, *как* она должна работать. Они не описывают конкретные функции, но задают ограничения и стандарты производительности, безопасности, удобства и других аспектов.\n\n**Примеры нефункциональных требований:**\n- Система должна обрабатывать не менее 1000 запросов в секунду.\n- Время отклика интерфейса не должно превышать 2 секунд.\n- Все данные передаются по зашифрованному соединению (HTTPS).\n- Интерфейс должен поддерживать русский и английский языки.\n- Система должна быть доступна 99,9% времени в год (SLA).\n\nКатегории нефункциональных требований:\n- **Производительность** — скорость, нагрузка, время отклика.\n- **Надежность** — устойчивость к сбоям, доступность.\n- **Безопасность** — защита данных, аутентификация, авторизация.\n- **Масштабируемость** — способность системы расти при увеличении нагрузки.\n- **Юзабилити** — удобство использования интерфейса.\n- **Поддерживаемость** — легкость внесения изменений и исправления ошибок.\n- **Портабельность** — возможность запуска на разных платформах.\n\n#### Как собирать требования\n\nСбор требований — это итеративный процесс взаимодействия с заинтересованными сторонами (стейкхолдерами): заказчиками, пользователями, аналитиками, разработчиками. Методы включают:\n\n1. **Интервью** — прямое общение с ключевыми стейкхолдерами для выявления целей и ожиданий.\n2. **Опросы и анкетирование** — сбор мнений у большой группы пользователей.\n3. **Фокус-группы** — обсуждение требований в группе потенциальных пользователей.\n4. **Анализ существующих систем** — изучение аналогов или устаревших версий ПО.\n5. **Работа с пользовательскими историями и Use Case** — формализация сценариев использования.\n6. **Мастер-классы (workshops)** — совместные сессии с участием всех заинтересованных сторон.\n\n#### Анализ и уточнение требований\n\nПосле сбора требования анализируются на:\n- **Полноту** — все ли необходимые функции учтены.\n- **Непротиворечивость** — нет ли конфликтов между требованиями.\n- **Реализуемость** — можно ли технически реализовать требование.\n- **Проверяемость** — можно ли протестировать выполнение требования.\n- **Приоритет** — насколько важно требование (например, по методу MoSCoW: Must have, Should have, Could have, Won’t have).\n\n#### Документирование требований\n\nФормализованное представление требований позволяет избежать недопонимания и служит основой для проектирования и тестирования. Формы документирования:\n\n- **Спецификация требований к программному обеспечению (Software Requirements Specification, SRS)** — структурированный документ, включающий функциональные и нефункциональные требования.\n- **Use Case Diagrams (диаграммы вариантов использования)** — визуализация взаимодействия пользователей с системой (часть UML).\n- **Пользовательские истории в трекерах задач** (Jira, Trello) — с приоритетами, оценками и критериями приемки.\n- **Диаграммы потоков данных (DFD)** — показывают, как данные перемещаются между компонентами системы.\n\nВ соответствии с **ГОСТ 34.601-90** (и другими стандартами), требования должны быть:\n- Однозначными,\n- Измеримыми,\n- Проверяемыми,\n- Поддерживаемыми,\n- Согласованными с заказчиком.\n\n#### Заключение\n\nКачественное управление требованиями — залог успеха любого IT-проекта. Ошибки на этапе сбора и анализа требований часто приводят к превышению бюджета, срыву сроков и созданию неработоспособного ПО. Использование UML, стандартизированных форматов документирования и системного подхода позволяет минимизировать риски и создавать программные продукты, соответствующие реальным потребностям пользователей."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Пользовательские истории и диаграммы Use Case: построение, акторы, расширения, включения\n\n#### Пользовательские истории (User Stories)\n\n**Пользовательская история** — это краткое, простое описание функциональности системы с точки зрения конечного пользователя. Она помогает команде разработки понять, *кто* хочет выполнить действие, *что* он хочет сделать и *зачем*.\n\nФормат пользовательской истории:\n> *«Как [роль], я хочу [цель], чтобы [выгода]»*\n\n**Пример:**\n> *«Как пользователь, я хочу войти в систему с помощью логина и пароля, чтобы получить доступ к своему личному кабинету»*\n\n**Ключевые характеристики пользовательских историй (по критериям INVEST):**\n- **I**ndependent — независимая\n- **N**egotiable — подлежит обсуждению\n- **V**aluable — ценная для пользователя\n- **E**stimable — поддаётся оценке\n- **S**mall — достаточно мала для реализации\n- **T**estable — проверяема\n\nПользовательские истории используются в гибких методологиях (например, Scrum) как основа для планирования и разработки.\n\n---\n\n#### Диаграммы Use Case (диаграммы вариантов использования)\n\n**Диаграмма Use Case** — это графическое представление взаимодействия между акторами (пользователями или внешними системами) и системой. Она показывает, *какие функции* предоставляет система и *кто* их использует.\n\n##### Основные элементы диаграммы:\n\n1. **Актор (Actor)**\n   - Обозначает роль пользователя или внешней системы, взаимодействующей с системой.\n   - На диаграмме изображается человечком.\n   - Примеры: *Пользователь, Администратор, Платёжная система, CRM-система*\n\n2. **Use Case (вариант использования)**\n   - Функция или поведение системы, предоставляемое актору.\n   - Изображается овалом.\n   - Название — глагол или глагольная фраза: *«Создать заказ», «Оплатить счёт», «Просмотреть отчёт»*\n\n3. **Система (System Boundary)**\n   - Прямоугольник, обозначающий границы системы. Внутри него размещаются Use Case.\n\n4. **Связи между элементами**\n   - **Ассоциация (Association)** — линия между актором и Use Case. Показывает взаимодействие.\n   - **Включение (Include)** — стрелка с надписью `<<include>>`, пунктирная линия. Используется, когда один Use Case *обязательно включает* другой.\n     - Пример: *«Оплатить заказ» включает «Проверить наличие товара»*\n   - **Расширение (Extend)** — стрелка с надписью `<<extend>>`. Используется, когда один Use Case *дополняет* другой при определённых условиях.\n     - Пример: *«Отправить уведомление» расширяет «Создать заказ», если включены уведомления*\n   - **Наследование (Generalization)** — стрелка с пустым треугольником. Показывает, что один актор или Use Case является специализацией другого.\n\n---\n\n#### Примеры из реальных систем\n\n**1. Интернет-магазин (например, Wildberries или Ozon)**\n\n- **Акторы:** Покупатель, Администратор, Платёжный шлюз, Служба доставки\n- **Use Case:**\n  - «Добавить товар в корзину»\n  - «Оформить заказ»\n  - «Оплатить заказ» (включает «Проверить данные карты»)\n  - «Отследить доставку»\n  - «Отменить заказ» (расширяется «Вернуть деньги», если оплата уже прошла)\n\n**2. Банковская система (онлайн-банкинг)**\n\n- **Акторы:** Клиент, Оператор, Система безопасности, Внешний сервис (например, СБП)\n- **Use Case:**\n  - «Просмотреть баланс»\n  - «Перевести деньги» (включает «Подтвердить транзакцию по SMS»)\n  - «Заблокировать карту» (расширяется «Уведомить службу поддержки»)\n\n**3. Система управления обучением (LMS, например, Moodle)**\n\n- **Акторы:** Студент, Преподаватель, Администратор\n- **Use Case:**\n  - «Сдать тест»\n  - «Просмотреть оценки»\n  - «Загрузить материал» (включает «Проверить формат файла»)\n  - «Оставить отзыв» (расширяет «Завершить курс»)\n\n---\n\n#### Связь между пользовательскими историями и Use Case\n\n| Пользовательская история | → | Use Case |\n|----------------------------|---|----------|\n| Описывает потребность пользователя | | Описывает функциональность системы |\n| Текстовая форма | | Графическая модель |\n| Используется в Agile | | Используется в UML и традиционных методах |\n\nНа практике пользовательские истории часто трансформируются в Use Case при переходе от идеи к проектированию. Это позволяет формализовать требования и подготовить систему к разработке.\n\n---\n\n#### Зачем это нужно?\n\n- **Чёткое понимание требований** — все участники видят, что система должна делать.\n- **Выявление скрытых сценариев** — через расширения и включения.\n- **Документирование поведения** — удобно для тестирования и поддержки.\n- **Коммуникация между командами** — бизнес, аналитики, разработчики говорят на одном языке.\n\nИспользование пользовательских историй и диаграмм Use Case — это важный шаг от идеи к реализуемой, тестируемой и поддерживаемой системе."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "# Диаграммы последовательности: моделирование взаимодействия объектов во времени\n\nДиаграмма последовательности (Sequence Diagram) — один из ключевых типов диаграмм в языке визуального моделирования UML (Unified Modeling Language). Она используется для отображения взаимодействия между объектами в системе с акцентом на **хронологический порядок сообщений**, передаваемых между ними. Диаграммы последовательности особенно полезны на этапах проектирования и анализа поведения системы, поскольку позволяют визуализировать динамику процессов, например, выполнение сценариев использования (use cases).\n\n## Назначение диаграмм последовательности\n\nОсновная цель диаграммы последовательности — показать:\n- Какие объекты участвуют в определённом сценарии;\n- В каком порядке происходит обмен сообщениями;\n- Какие операции вызываются и как система реагирует на внешние или внутренние события.\n\nТакие диаграммы широко применяются при проектировании программного обеспечения для:\n- Детализации пользовательских сценариев;\n- Проверки корректности логики взаимодействия компонентов;\n- Обнаружения потенциальных ошибок в потоке управления;\n- Документирования поведения системы.\n\n## Основные элементы диаграммы последовательности\n\n### 1. Объекты (Objects)\n\nОбъекты представляют экземпляры классов, участвующие во взаимодействии. На диаграмме они изображаются в виде прямоугольников, расположенных в верхней части диаграммы. Имя объекта может быть указано с типом:\n- `:Класс` — анонимный объект;\n- `объект:Класс` — объект с именем.\n\nПример: `пользователь:Пользователь`, `db:БазаДанных`.\n\n### 2. Линии жизни (Lifelines)\n\nЛиния жизни — вертикальная пунктирная линия, исходящая вниз от объекта. Она символизирует существование объекта во времени в рамках рассматриваемого взаимодействия. Линия жизни показывает, когда объект активен, и служит «осью времени» для данного объекта.\n\n### 3. Активации (Activations)\n\nАктивация (или «фокус управления») — прямоугольник, накладываемый на линию жизни. Он обозначает период, в течение которого объект выполняет какую-либо операцию (например, обработку метода). Активации могут быть вложенными, если один объект вызывает другой.\n\n### 4. Сообщения (Messages)\n\nСообщения — горизонтальные стрелки, соединяющие линии жизни объектов. Они представляют вызовы методов, передачу данных или сигналы между объектами. Сообщения располагаются в хронологическом порядке сверху вниз.\n\nТипы сообщений:\n- **Синхронное сообщение** (сплошная стрелка с закрашенным концом) — отправитель ждёт ответа (например, вызов метода).\n- **Асинхронное сообщение** (сплошная стрелка с незакрашенным концом) — отправитель не ждёт ответа (например, отправка события).\n- **Возвратное сообщение** (пунктирная стрелка) — возврат результата или завершение операции.\n- **Самовызов** — сообщение от объекта к самому себе (для внутренней логики).\n\n## Пример простой диаграммы последовательности\n\n**Сценарий**: Пользователь входит в систему.\n\n1. `пользователь:Пользователь` отправляет сообщение `вход(логин, пароль)` объекту `аутентификатор:Аутентификатор`.\n2. `аутентификатор` активируется и отправляет `проверить(логин, пароль)` объекту `db:БазаДанных`.\n3. `db` возвращает результат.\n4. `аутентификатор` возвращает `успех` или `ошибка`.\n5. `пользователь` получает результат.\n\n## Преимущества использования диаграмм последовательности\n\n- Наглядное представление временной логики взаимодействия.\n- Упрощение анализа сложных сценариев.\n- Поддержка командной разработки — все участники видят одинаковую модель поведения.\n- Возможность выявить избыточные или отсутствующие вызовы.\n\n## Рекомендации по построению\n\n- Диаграммы должны быть сфокусированы на одном сценарии.\n- Избегайте чрезмерной детализации — не нужно включать все возможные ветки логики.\n- Используйте фреймы (фрагменты) для обозначения условий (`alt`), циклов (`loop`) и опциональных блоков (`opt`).\n\n## Заключение\n\nДиаграммы последовательности — мощный инструмент в арсенале разработчика и аналитика. Они помогают формализовать поведение системы, улучшить качество проектирования и снизить риски ошибок на ранних этапах разработки. Освоение этой нотации является важной частью компетенции в области проектирования ПО и соответствует целям модуля по созданию чётких, стандартизированных моделей системы."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "# Диаграммы классов: структура системы, атрибуты, методы, ассоциации, наследование, агрегация, композиция\n\nДиаграмма классов (Class Diagram) — один из ключевых типов диаграмм в языке визуального моделирования UML (Unified Modeling Language). Она используется для описания статической структуры системы, отображая классы, их атрибуты, методы и взаимосвязи между ними. Диаграммы классов особенно важны на этапах проектирования программного обеспечения, так как позволяют формализовать архитектуру системы, обеспечить чёткое понимание компонентов и их взаимодействия, а также служат основой для разработки кода.\n\n## Основные элементы диаграммы классов\n\n### Класс\n\nКласс — это шаблон, описывающий состояние и поведение объектов одного типа. На диаграмме класс изображается в виде прямоугольника, разделённого на три секции:\n\n1. **Имя класса** — располагается в верхней части прямоугольника. Имя пишется жирным шрифтом и центрируется.\n2. **Атрибуты** — перечисляются в средней секции. Описывают свойства класса (данные).\n3. **Методы** — перечисляются в нижней секции. Описывают поведение класса (операции).\n\nПример:\n```\n+---------------------+\n|    Класс Автомобиль   |\n+---------------------+\n| - марка: строка      |\n| - модель: строка     |\n| - годВыпуска: целое   |\n+---------------------+\n| + завести(): void    |\n| + остановить(): void |\n+---------------------+\n```\n\n### Атрибуты и методы\n\n- **Атрибуты** — это переменные, принадлежащие классу. Они определяют состояние объекта. Указываются с модификатором доступа:\n  - `+` — публичный (public)\n  - `-` — приватный (private)\n  - `#` — защищённый (protected)\n  - `~` — пакетный (package)\n\n- **Методы** — это функции или процедуры, определяющие поведение объекта. Также указываются с модификатором доступа и могут включать параметры и тип возвращаемого значения.\n\nПример записи:\n```\n- имя: строка\n+ getИмя(): строка\n+ setИмя(новоеИмя: строка): void\n```\n\n## Взаимосвязи между классами\n\nВ UML определено несколько типов отношений между классами, которые отражают структурные зависимости.\n\n### 1. Ассоциация\n\n**Ассоциация** — это связь между двумя или более классами, показывающая, что объекты этих классов могут взаимодействовать. Ассоциация может быть именованной и иметь направление.\n\nПример: `Автомобиль` — `Водитель`\n- Один водитель может управлять несколькими автомобилями.\n- Один автомобиль может управляться одним водителем.\n\nНа диаграмме изображается линией между классами, может быть подписано именем ассоциации и уточнено кратностью (multiplicity):\n- `0..1` — ноль или один\n- `1` — ровно один\n- `0..*` или `*` — ноль или более\n- `1..*` — один или более\n\n```\n+-------------+       управляет       +-------------+\n|  Водитель   |<--------------------->| Автомобиль  |\n+-------------+     1         0..*    +-------------+\n```\n\n### 2. Наследование (обобщение)\n\n**Наследование** (или обобщение, generalization) — это отношение «является разновидностью». Один класс (подкласс) наследует атрибуты и методы другого класса (суперкласса).\n\nНа диаграмме изображается сплошной линией с пустой стрелкой от подкласса к суперклассу.\n\nПример:\n```\n        +-------------+\n        |   Транспорт  |\n        +-------------+\n               ^\n               |\n    +----------+----------+\n    |                     |\n+-------+             +---------+\n| Авто |             |  Велосипед |\n+-------+             +---------+\n```\n\n### 3. Агрегация\n\n**Агрегация** — это отношение «целое-часть», при котором часть может существовать независимо от целого. Это слабая форма композиции.\n\nИзображается линией с пустым ромбом у стороны целого.\n\nПример: `Компьютер` — `Монитор`\n- Монитор может существовать отдельно от компьютера.\n\n```\n+-----------+          +------------+\n| Компьютер |<>--------| Монитор    |\n+-----------+          +------------+\n    агрегация\n```\n\n### 4. Композиция\n\n**Композиция** — это сильная форма агрегации, при которой часть не может существовать без целого. Если целое уничтожается, части также уничтожаются.\n\nИзображается линией с закрашенным ромбом у стороны целого.\n\nПример: `Дом` — `Комната`\n- Комната не существует отдельно от дома.\n\n```\n+------+          +---------+\n| Дом  |◆---------| Комната |\n+------+          +---------+\n  композиция\n```\n\n## Практическое значение диаграмм классов\n\n- **Проектирование архитектуры**: помогает визуализировать структуру системы до написания кода.\n- **Коммуникация в команде**: служит общим языком для разработчиков, аналитиков и тестировщиков.\n- **Генерация кода**: многие CASE-средства (например, Enterprise Architect, Visual Paradigm) позволяют генерировать каркас кода на основе диаграмм.\n- **Документирование**: является частью технической документации, соответствующей современным стандартам.\n\n## Заключение\n\nДиаграммы классов — это мощный инструмент проектирования ПО, позволяющий формализовать структуру системы, выявить ключевые компоненты и их взаимосвязи. Понимание таких концепций, как атрибуты, методы, ассоциации, наследование, агрегация и композиция, необходимо для создания масштабируемых, поддерживаемых и гибких систем. Освоение UML-моделирования способствует предотвращению ошибок на ранних этапах разработки и повышает качество конечного продукта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Другие UML-диаграммы: обзор диаграмм состояний, активности и компонентов — когда и зачем использовать\n\nUML (Unified Modeling Language) предоставляет широкий набор диаграмм для моделирования различных аспектов программного обеспечения. Помимо уже знакомых диаграмм вариантов использования (Use Case), классов и последовательностей, важную роль играют диаграммы состояний, активности и компонентов. Каждая из них решает свои задачи и применяется на определённых этапах проектирования.\n\n#### 1. Диаграмма состояний (State Machine Diagram)\n\n**Что показывает:**\nДиаграмма состояний описывает, как объект или система реагирует на события, изменяя своё состояние. Она отражает жизненный цикл объекта — все возможные состояния и переходы между ними.\n\n**Когда использовать:**\n- Когда поведение объекта сильно зависит от его текущего состояния.\n- Для моделирования сложных процессов с множеством условий и переходов (например, заказ в интернет-магазине: \"создан\", \"оплачен\", \"в обработке\", \"доставлен\", \"отменён\").\n- В системах реального времени или встроенных системах, где важна реакция на события.\n\n**Примеры применения:**\n- Автоматизация бизнес-процессов.\n- Управление жизненным циклом документа или заявки.\n- Моделирование поведения игровых персонажей или устройств.\n\n> **Совет:** Используйте диаграмму состояний, если замечаете, что в коде появляется множество условных операторов (`if`, `switch`), зависящих от \"состояния\" объекта.\n\n---\n\n#### 2. Диаграмма активности (Activity Diagram)\n\n**Что показывает:**\nДиаграмма активности — это визуальное представление потока выполнения процесса, похожее на блок-схему. Она показывает последовательность действий, ветвления, слияния, параллельные потоки и точки принятия решений.\n\n**Когда использовать:**\n- Для моделирования бизнес-процессов или алгоритмов.\n- Когда нужно показать, как выполняется операция, особенно если в ней есть параллельные или условные ветки.\n- Для документирования сложной логики, например, процесса авторизации, обработки платежа или генерации отчёта.\n\n**Особенности:**\n- Поддерживает моделирование параллелизма (разделение и слияние потоков).\n- Удобна для коммуникации с нетехническими заинтересованными сторонами (бизнес-аналитиками, заказчиками).\n\n> **Аналог:** Можно рассматривать как продвинутую блок-схему, но с семантикой UML и поддержкой объектно-ориентированных концепций.\n\n---\n\n#### 3. Диаграмма компонентов (Component Diagram)\n\n**Что показывает:**\nДиаграмма компонентов отображает архитектурную структуру системы на уровне модулей (компонентов) и их зависимостей. Компонент — это автономная часть системы, которая предоставляет и использует чётко определённые интерфейсы.\n\n**Когда использовать:**\n- На этапе проектирования архитектуры ПО.\n- Для визуализации модульности системы и взаимодействия между модулями.\n- При разработке многомодульных или распределённых систем (например, микросервисов).\n- Чтобы показать, как компоненты зависят друг от друга и какие интерфейсы они предоставляют.\n\n**Примеры компонентов:**\n- Модуль аутентификации.\n- Сервис обработки платежей.\n- Библиотека логирования.\n\n> **Преимущество:** Помогает избежать жёсткой связанности (tight coupling) и способствует повторному использованию кода.\n\n---\n\n### Сравнительная таблица\n\n| Диаграмма         | Основной фокус               | Уровень абстракции     | Когда применять?                          |\n|--------------------|-------------------------------|------------------------|--------------------------------------------|\n| **Состояний**      | Поведение объекта во времени  | Объект / компонент     | Сложные жизненные циклы, реакция на события |\n| **Активности**     | Поток выполнения процесса     | Процесс / операция     | Алгоритмы, бизнес-логика, ветвления        |\n| **Компонентов**    | Структура системы             | Архитектура / система   | Проектирование модульности и зависимостей  |\n\n---\n\n### Заключение\n\nВыбор диаграммы зависит от того, **что именно вы хотите смоделировать**:\n- **Поведение объекта?** → Диаграмма состояний.\n- **Логику процесса?** → Диаграмма активности.\n- **Структуру системы?** → Диаграмма компонентов.\n\nИспользование этих диаграмм помогает глубже понять систему, выявить скрытые требования, упростить разработку и улучшить документацию. Они становятся мостом между требованиями, архитектурой и реализацией, особенно в командах, где важна чёткая коммуникация."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Инструменты UML: PlantUML, StarUML, Lucidchart. Работа в команде над диаграммами\n\nДля эффективного проектирования программного обеспечения с использованием UML (Unified Modeling Language) разработчики и аналитики применяют специализированные инструменты визуализации. Эти инструменты помогают создавать, редактировать и совместно использовать диаграммы, что особенно важно при работе в команде. Рассмотрим три популярных решения: **PlantUML**, **StarUML** и **Lucidchart**.\n\n#### 1. PlantUML\n\n**PlantUML** — это текстовый инструмент для создания UML-диаграмм на основе описания на простом языке разметки. Вместо рисования элементов мышью, пользователь пишет код, который затем преобразуется в визуальную диаграмму.\n\n**Преимущества:**\n- Поддержка версионного контроля (например, через Git), так как диаграммы хранятся в виде текста.\n- Лёгкая интеграция с документацией (Markdown, Confluence, Jira).\n- Подходит для автоматизации и CI/CD.\n- Бесплатный и с открытым исходным кодом.\n\n**Недостатки:**\n- Требует изучения синтаксиса.\n- Ограниченная поддержка сложных визуальных настроек.\n\n**Пример использования:**\n```plantuml\n@startuml\nactor User\nUser --> (Login)\nUser --> (View Profile)\n@enduml\n```\n\n#### 2. StarUML\n\n**StarUML** — это полнофункциональная настольная среда для UML-моделирования с графическим интерфейсом. Поддерживает широкий спектр диаграмм: Use Case, классов, последовательностей, состояний и др.\n\n**Преимущества:**\n- Богатый функционал и поддержка стандартов UML 2.x.\n- Расширяемость через плагины.\n- Экспорт в изображения, PDF, код и документацию.\n- Поддержка обратного проектирования (reverse engineering) из исходного кода.\n\n**Недостатки:**\n- Платная лицензия для полной версии.\n- Работа с файлами диаграмм менее удобна для совместного редактирования.\n\n**Применение:** Подходит для глубокого проектирования архитектуры ПО, особенно в средних и крупных проектах.\n\n#### 3. Lucidchart\n\n**Lucidchart** — это облачный инструмент для визуального моделирования, поддерживающий UML, BPMN, ER-диаграммы и другие типы схем.\n\n**Преимущества:**\n- Совместная работа в реальном времени (аналогично Google Docs).\n- Интуитивно понятный интерфейс перетаскивания (drag-and-drop).\n- Интеграция с Google Workspace, Microsoft Office, Confluence, Jira.\n- Хорошо подходит для межкомандного взаимодействия (разработчики, бизнес-аналитики, менеджеры).\n\n**Недостатки:**\n- Ограниченная поддержка строгих UML-стандартов по сравнению с StarUML.\n- Требует подключения к интернету.\n- Платная подписка для продвинутых функций.\n\n**Применение:** Идеален для команд, где важна скорость создания диаграмм и совместная работа.\n\n### Работа в команде над диаграммами\n\nСовместное создание UML-диаграмм — важная часть командной разработки. Эффективная работа требует:\n\n- **Единого стандарта оформления** — чтобы все участники понимали обозначения и структуру.\n- **Версионного контроля** — особенно при использовании PlantUML или хранении файлов StarUML в репозитории.\n- **Регулярных ревью диаграмм** — как часть технического обзора (design review).\n- **Интеграции с системами управления проектами** — например, размещение диаграмм в Confluence или Jira.\n- **Чёткого разделения ответственности** — кто создаёт, кто утверждает, кто поддерживает актуальность моделей.\n\n**Рекомендации:**\n- Используйте Lucidchart для быстрого прототипирования и обсуждений.\n- Применяйте StarUML для детального проектирования и генерации артефактов.\n- Внедряйте PlantUML в CI/CD и документацию для автоматизации.\n\nВыбор инструмента зависит от масштаба проекта, культуры команды и требований к формализации. В идеале команда должна комбинировать подходы, используя сильные стороны каждого инструмента."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Создание технической документации: структура, стандарты и интеграция диаграмм\n\nТехническая документация — это неотъемлемая часть жизненного цикла программного обеспечения. Она обеспечивает понимание системы всеми участниками проекта: разработчиками, тестировщиками, аналитиками, техническими писателями и заказчиками. Качественная документация снижает риски ошибок, упрощает сопровождение и передачу знаний, а также способствует соблюдению стандартов качества и безопасности.\n\n### Структура технической документации\n\nСтруктура технической документации зависит от целей, аудитории и выбранного стандарта, но в общем случае включает следующие основные разделы:\n\n1. **Введение**\n   - Назначение документа\n   - Область применения\n   - Целевая аудитория\n   - Ссылки на сопутствующие документы (требования, архитектура, спецификации)\n\n2. **Общее описание системы**\n   - Назначение ПО\n   - Основные функции\n   - Принципы работы\n   - Архитектурные особенности\n\n3. **Функциональные требования**\n   - Описание возможностей системы\n   - Пользовательские сценарии (use cases)\n   - Диаграммы прецедентов (Use Case Diagrams)\n\n4. **Нефункциональные требования**\n   - Производительность, безопасность, масштабируемость, доступность\n   - Ограничения (платформа, совместимость, стандарты)\n\n5. **Модели системы**\n   - Диаграммы классов (Class Diagrams)\n   - Диаграммы последовательности (Sequence Diagrams)\n   - Диаграммы состояний (State Machine Diagrams)\n   - Диаграммы компонентов и развёртывания\n\n6. **Интерфейсы**\n   - Пользовательские интерфейсы (UI)\n   - API (входные/выходные параметры, форматы данных)\n\n7. **Требования к установке и настройке**\n   - Системные требования\n   - Процесс развёртывания\n   - Конфигурационные файлы\n\n8. **Требования к тестированию и валидации**\n   - Стратегия тестирования\n   - Тестовые сценарии\n   - Критерии приёмки\n\n9. **Приложения**\n   - Глоссарий терминов\n   - Диаграммы в высоком разрешении\n   - Примеры запросов и ответов\n\n---\n\n### Основные стандарты технической документации\n\n#### ГОСТ 19 — Единая система программной документации (ЕСПД)\n\nГОСТ 19 — это советский и российский стандарт, регламентирующий оформление программной документации. Он включает более 30 документов, охватывающих все этапы разработки ПО.\n\nНаиболее значимые документы серии:\n\n- **ГОСТ 19.101–77** — Виды программ и программных документов\n- **ГОСТ 19.201–78** — Техническое задание. Структура и правила оформления\n- **ГОСТ 19.402–78** — Описание программы\n- **ГОСТ 19.504–79** — Руководство оператора\n\nПреимущества ГОСТ 19:\n- Чёткая структура\n- Поддержка в государственных и оборонных организациях РФ\n- Унификация процессов\n\nНедостатки:\n- Устаревший стиль (ориентирован на бумажные документы)\n- Мало внимания к итеративным процессам и Agile\n- Ограниченная поддержка в международных проектах\n\n#### ISO/IEC/IEEE 26514:2018 — User Documentation\n\nЭтот международный стандарт определяет требования к созданию документации для пользователей программного обеспечения. Он ориентирован на практики технического писательства и поддерживает современные подходы к разработке.\n\nКлючевые аспекты стандарта:\n\n- Адаптация под целевую аудиторию\n- Использование модульного подхода (topic-based authoring)\n- Поддержка многоканальной публикации (веб, PDF, справка в приложении)\n- Интеграция с процессами разработки (Agile, DevOps)\n- Требования к структуре, стилю, ясности и доступности текста\n\nISO/IEC/IEEE 26514 особенно актуален для коммерческих и международных проектов, где важна юзабилити и поддержка пользователей.\n\n---\n\n### Интеграция UML-диаграмм в техническую документацию\n\nUML (Unified Modeling Language) — это стандарт визуального моделирования, позволяющий наглядно представлять структуру, поведение и архитектуру системы. Диаграммы UML играют ключевую роль в технической документации, делая её более понятной и точной.\n\n#### Как и где использовать диаграммы:\n\n- **Use Case Diagram** — в разделе функциональных требований, показывает взаимодействие пользователей с системой.\n- **Class Diagram** — в описании архитектуры, отражает структуру данных и связи между классами.\n- **Sequence Diagram** — для описания сценариев взаимодействия объектов во времени (например, процесс авторизации).\n- **State Machine Diagram** — для моделирования жизненного цикла объектов (например, статусов заказа).\n- **Component и Deployment Diagrams** — в технических приложениях, показывают физическую архитектуру и развёртывание системы.\n\n#### Рекомендации по интеграции:\n\n1. **Подписывайте все диаграммы** — указывайте номер, название и краткое описание.\n2. **Ссылайтесь на диаграммы в тексте** — например: «Процесс оплаты описан на диаграмме последовательности (рис. 3.2)».\n3. **Используйте единый стиль оформления** — цвета, шрифты, нотации.\n4. **Обеспечьте актуальность** — диаграммы должны обновляться при изменениях в системе.\n5. **Включайте легенду**, если используются нестандартные обозначения.\n\n---\n\n### Заключение\n\nСоздание технической документации — это не формальность, а важный инженерный процесс. Использование стандартов (ГОСТ 19, ISO/IEC/IEEE 26514) и UML-диаграмм позволяет повысить качество, читаемость и долгосрочную поддерживаемость документации. В условиях роста сложности ПО и командной разработки грамотно оформленная документация становится критическим активом проекта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Практическое задание: Проектирование системы бронирования билетов с использованием UML\n\n#### Цель задания\nНаучиться применять методы и нотации UML для проектирования программной системы на примере реального кейса — **системы бронирования билетов** (например, на транспорт, в кинотеатр или на мероприятие). В ходе задания студенты соберут требования, построят ключевые UML-диаграммы и подготовят техническую документацию.\n\n---\n\n#### Шаг 1: Сбор и формализация требований\n\n**Функциональные требования:**\n1. Пользователь может просматривать доступные события (сеансы, рейсы и т.п.).\n2. Пользователь может выбирать место и бронировать его.\n3. Система должна проверять доступность мест.\n4. Пользователь может оплачивать бронирование.\n5. Система генерирует электронный билет после оплаты.\n6. Администратор может добавлять/редактировать события и места.\n7. Система отправляет уведомления о бронировании (email/SMS).\n\n**Нефункциональные требования:**\n- Отклик системы — не более 2 секунд.\n- Поддержка до 10 000 одновременных пользователей.\n- Доступность системы — 99,9% в год.\n- Данные пользователей должны быть защищены (соответствие GDPR).\n\n**Пользовательские истории (User Stories):**\n- Как пользователь, я хочу видеть список доступных сеансов, чтобы выбрать подходящий.\n- Как пользователь, я хочу забронировать место, чтобы гарантировать его за собой.\n- Как администратор, я хочу загружать расписание событий, чтобы обновлять информацию.\n\n---\n\n#### Шаг 2: Диаграмма прецедентов (Use Case Diagram)\n\n**Акторы:**\n- Пользователь (Клиент)\n- Администратор\n- Платежная система (внешняя)\n\n**Прецеденты:**\n- Просмотр событий\n- Выбор места\n- Бронирование места\n- Оплата\n- Получение билета\n- Управление событиями (админ)\n- Отправка уведомления\n\n**Пример структуры диаграммы:**\n```\n[Пользователь] — (Просмотр событий)\n[Пользователь] — (Выбор места)\n[Пользователь] — (Бронирование)\n[Пользователь] — (Оплата)\n[Пользователь] — (Получение билета)\n[Администратор] — (Управление событиями)\n[Система] —> (Отправка уведомления)\n[Платежная система] <—> (Оплата)\n```\n\n> **Рекомендация:** Используйте инструменты визуализации (StarUML, Lucidchart, draw.io) для построения диаграммы.\n\n---\n\n#### Шаг 3: Диаграмма последовательности (Sequence Diagram)\n\n**Сценарий:** Бронирование и оплата места\n\n**Объекты:**\n- Пользователь\n- Интерфейс (UI)\n- Сервис бронирования\n- Сервис оплаты\n- База данных\n- Сервис уведомлений\n\n**Последовательность:**\n1. Пользователь → UI: Выбирает место\n2. UI → Сервис бронирования: Запрос на бронирование\n3. Сервис бронирования → База данных: Проверка доступности\n4. База данных → Сервис бронирования: Ответ о доступности\n5. Сервис бронирования → UI: Подтверждение брони\n6. Пользователь → UI: Подтверждает оплату\n7. UI → Сервис оплаты: Запрос на оплату\n8. Сервис оплаты → Платежная система: Обработка платежа\n9. Платежная система → Сервис оплаты: Успешный платёж\n10. Сервис оплаты → Сервис бронирования: Подтверждение оплаты\n11. Сервис бронирования → База данных: Фиксация билета\n12. Сервис бронирования → Сервис уведомлений: Отправить билет\n13. Сервис уведомлений → Пользователь: Отправка email/SMS\n\n> Диаграмма отражает временной порядок взаимодействий и помогает выявить точки отказа.\n\n---\n\n#### Шаг 4: Диаграмма классов (Class Diagram)\n\n**Основные классы:**\n\n- `Пользователь`\n  - id: String\n  - имя: String\n  - email: String\n  - методы: авторизоваться(), получитьИсторию()\n\n- `Событие`\n  - id: String\n  - название: String\n  - дата: DateTime\n  - место: String\n\n- `Место`\n  - номер: String\n  - ряд: String\n  - статус: Enum (свободно, забронировано, продано)\n\n- `Бронирование`\n  - id: String\n  - дата: DateTime\n  - статус: Enum\n  - ассоциации: ← Пользователь, ← Место, ← Событие\n\n- `Оплата`\n  - id: String\n  - сумма: Double\n  - статус: Enum\n  - методы: провести(), отменить()\n\n- `Билет`\n  - id: String\n  - QR-код: String\n  - ассоциации: ← Бронирование\n\n**Связи:**\n- Пользователь создаёт Бронирование\n- Бронирование включает Место и Событие\n- Бронирование связано с Оплатой\n- Оплата подтверждает выпуск Билета\n\n> Диаграмма помогает спроектировать структуру базы данных и API.\n\n---\n\n#### Шаг 5: Оформление технической документации\n\nДокумент должен включать:\n1. **Введение** — цель, область применения.\n2. **Требования** — функциональные и нефункциональные.\n3. **Модели UML** — вложения диаграмм с пояснениями.\n4. **Описание классов и интерфейсов**.\n5. **Сценарии использования**.\n6. **Приложения** — ссылки на инструменты, источники.\n\n> **Формат:** PDF или DOCX. Рекомендуется следовать структуре ГОСТ 19.101-77 (ЕСПД) для программной документации.\n\n---\n\n#### Критерии оценки\n- Полнота и корректность требований\n- Адекватность и соответствие стандартам UML\n- Логическая согласованность между диаграммами\n- Качество оформления документа\n- Наличие пояснений и комментариев\n\n---\n\n#### Рекомендации\n- Начните с анализа предметной области.\n- Согласуйте границы системы (что входит, а что — внешние акторы).\n- Проверьте, все ли прецеденты покрыты диаграммами.\n- Используйте именование по правилам domain-driven design (например, `Бронирование`, а не `BookingManager`).\n\n> Это задание формирует навыки системного мышления, командной разработки и профилактики ошибок на этапе проектирования — ключевых компетенций инженера ПО."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 2: Проектирование ПО и UML-моделирование",
        "max_score": 100,
        "passing_score": 60,
        "questions": [
          {
            "text": "Опишите, почему моделирование программного обеспечения с использованием UML является критически важным этапом разработки. Приведите три конкретных примера последствий отсутствия проектирования из реальных IT-проектов, рассмотренных в модуле, и объясните, как применение UML-диаграмм могло бы предотвратить каждый из этих провалов.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Сравните три модели жизненного цикла ПО — каскадную, итеративную и Agile — с точки зрения роли и места этапа проектирования. В каком из подходов проектирование выполняется единожды, а в каком — непрерывно? Какие преимущества и риски связаны с каждым подходом в контексте управления архитектурными решениями? Приведите пример проекта, для которого каждый из подходов был бы наиболее подходящим, и обоснуйте свой выбор.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Что такое функциональные и нефункциональные требования? Приведите по три примера каждого типа применительно к системе бронирования билетов. Опишите, как методы сбора требований (например, интервью, фокус-группы, анализ аналогов) помогают сформировать полную картину ожиданий от системы. Какие критерии (например, проверяемость, реализуемость) используются для анализа требований, и почему они важны?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Постройте диаграмму прецедентов (Use Case Diagram) для системы бронирования билетов. Определите акторов, основные и вспомогательные прецеденты, а также используйте отношения «включение» (include) и «расширение» (extend). Объясните, зачем нужны эти отношения и как они улучшают читаемость и точность модели. Приведите пример использования каждого типа связи в контексте вашей диаграммы.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "На основе сценария «Пользователь бронирует и оплачивает место» постройте диаграмму последовательности (Sequence Diagram). Укажите все участвующие объекты, линии жизни, активации и сообщения (включая синхронные и возвратные). Объясните, как данная диаграмма помогает выявить потенциальные узкие места или ошибки в логике взаимодействия компонентов до начала реализации.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Создайте диаграмму классов (Class Diagram) для той же системы бронирования. Включите ключевые классы (например, Пользователь, Событие, Место, Бронирование, Оплата, Билет), определите их атрибуты и методы. Покажите связи между классами — ассоциации, агрегацию, композицию и наследование (если применимо). Объясните разницу между агрегацией и композицией на примере из вашей диаграммы.",
            "options": [],
            "correct_answers": [],
            "points": 15
          }
        ]
      }
    },
    {
      "id": "3ce39ec0-7d5d-4355-997c-fb8df5f42829",
      "title": "Модуль 3: Управление проектом и командная разработка (Agile/Scrum)",
      "description": "В этом модуле студенты погружаются в практики управления IT-проектами с акцентом на гибкие методологии, в первую очередь — Scrum. На фоне осознания недостатков хаотичной разработки, студенты учатся организовывать командную работу, планировать итерации, управлять требованиями и отслеживать прогресс. Модуль формирует системное мышление и ответственность за проект как целостный процесс, а не набор отдельных задач.",
      "learning_objectives": [
        "Применять методологии Agile (Scrum) для управления учебным проектом.",
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
        "Создать техническую документацию по ГОСТ и современным стандартам.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 3,
      "content_blocks": [
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Введение в управление IT-проектами: почему большинство проектов срываются?\n\nУправление IT-проектами — это не просто контроль за сроками и бюджетом, а сложный процесс координации людей, технологий, требований и изменений. Согласно исследованиям Standish Group (CHAOS Report), до 70% IT-проектов сталкиваются с задержками, превышением бюджета или частичным провалом. Почему так происходит?\n\n#### Причины провалов IT-проектов\n\n1. **Нечёткие или изменяющиеся требования** — одна из главных причин. Заказчики часто не могут сформулировать свои потребности на старте, а разработчики строят систему на основе неполных данных.\n2. **Плохая коммуникация в команде и с заказчиком** — отсутствие прозрачности, редкие встречи, игнорирование обратной связи.\n3. **Нереалистичные сроки и недооценка сложности** — давление со стороны бизнеса приводит к оптимистичному планированию без учёта рисков.\n4. **Отсутствие гибкости** — невозможность адаптироваться к изменениям в процессе разработки.\n5. **Технический долг и слабая архитектура** — быстрые «костыли» в коде накапливаются и ведут к коллапсу.\n\n#### Кейсы провалов\n\n**1. Healthcare.gov (2013, США)**\n\nСайт для регистрации на медицинское страхование, запущенный в рамках реформы Обамы, стал символом провала крупного IT-проекта. При запуске сайт не выдержал нагрузки: пользователи не могли зарегистрироваться, система падала.\n\n**Причины провала:**\n- Использование **водопадной модели (Waterfall)** с жёстким планированием на годы вперёд.\n- Отсутствие тестирования в реальных условиях до релиза.\n- Множество подрядчиков без единого технического лидера.\n- Невозможность быстро исправить ошибки из-за длинных циклов разработки.\n\n**Итог:** Проект потребовал экстренного вмешательства команды из стартаперов, которые применили Agile-подход, чтобы починить систему за 6 недель.\n\n**2. Knight Capital Group (2012, США)**\n\nАмериканская финансовая компания потеряла **440 миллионов долларов за 45 минут** из-за ошибки в программном обеспечении.\n\n**Что произошло:**\n- При обновлении системы был активирован старый, неиспользуемый код.\n- Новое ПО начало массово покупать и продавать акции без контроля.\n- Из-за отсутствия тестирования и автоматических блокировок система вышла из-под контроля.\n\n**Причины:**\n- Отсутствие процессов CI/CD и автоматизированного тестирования.\n- Слабая система управления изменениями.\n- Недостаточная прозрачность и контроль в процессе развёртывания.\n\n**Итог:** Компания едва не обанкротилась и была вынуждена продаться.\n\n---\n\n### Сравнение Waterfall и Agile\n\n| Критерий | Waterfall (Водопад) | Agile (Гибкая методология) |\n|---------|----------------------|----------------------------|\n| **Подход** | Линейный, последовательный | Итеративный, итерационный |\n| **Изменения** | Практически невозможны после старта | Приветствуются и встраиваются в процесс |\n| **Требования** | Фиксируются на старте | Эволюционируют в процессе |\n| **Документация** | Высокая (ГОСТ, ТЗ, спецификации) | Минимально необходимая, акцент на рабочее ПО |\n| **Коммуникация** | Формальная, через документы | Постоянная, через встречи (daily, ретроспективы) |\n| **Релиз** | Один раз в конце проекта | Частые релизы (каждые 1–4 недели) |\n| **Риски** | Высокие — ошибки выявляются поздно | Низкие — обратная связь приходит быстро |\n\n#### Плюсы и минусы\n\n**Waterfall:**\n- ✅ Подходит для проектов с чёткими, стабильными требованиями (например, оборонные системы, медицинские устройства).\n- ✅ Простота планирования и контроля бюджета.\n- ❌ Не гибкий, плохо реагирует на изменения.\n- ❌ Ошибки выявляются слишком поздно.\n\n**Agile:**\n- ✅ Быстрая адаптация к изменениям.\n- ✅ Раннее получение обратной связи от пользователей.\n- ✅ Постоянный прогресс и прозрачность.\n- ❌ Требует высокой дисциплины и вовлечённости команды.\n- ❌ Сложно применять в строгих регулируемых средах без адаптации.\n\n#### Области применения\n\n- **Waterfall:** Проекты с фиксированными требованиями, где изменения невозможны или критичны по стоимости (например, космические миссии, ядерные системы).\n- **Agile:** Коммерческие IT-проекты, стартапы, веб- и мобильные приложения, где требования эволюционируют.\n\n---\n\n> **Вывод:** Большинство провалов IT-проектов связаны не с технологиями, а с управлением. Переход от жёстких моделей к гибким методологиям, таким как Agile и Scrum, позволяет минимизировать риски, быстрее реагировать на изменения и создавать продукт, который действительно нужен пользователям."
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "# Основы Agile: 4 ценности и 12 принципов Agile Manifesto\n\nВ 2001 году группа профессионалов в области разработки программного обеспечения собралась в Солт-Лейк-Сити, чтобы обсудить альтернативы традиционным, жёстким методологиям управления проектами. В результате этого собрания был принят **Манифест Agile (Agile Manifesto)** — документ, ставший основой гибких методологий разработки.\n\n## 4 ценности Agile Manifesto\n\nМанифест провозглашает четыре ключевые ценности, которые определяют философию Agile:\n\n1. **Люди и взаимодействие важнее процессов и инструментов**\n   - Успех проекта зависит в первую очередь от квалификации, мотивации и слаженной работы команды, а не от формальных процедур или используемых инструментов.\n\n2. **Работающий продукт важнее исчерпывающей документации**\n   - Приоритет — на создание программного обеспечения, которое решает реальные задачи пользователей. Документация важна, но не должна замедлять разработку.\n\n3. **Сотрудничество с заказчиком важнее согласования условий контракта**\n   - Заказчик — не внешняя сторона, а часть команды. Его постоянное вовлечение позволяет быстрее адаптироваться к изменениям и лучше понимать потребности.\n\n4. **Готовность к изменениям важнее следования первоначальному плану**\n   - В условиях неопределённости гибкость и способность перестраиваться ценятся выше, чем строгое следование изначальному графику.\n\n> **Важно**: Agile не отвергает процессы, документацию, контракты или планирование — он лишь утверждает, что перечисленные слева ценности важнее.\n\n## 12 принципов Agile\n\nНа основе этих ценностей сформулированы 12 принципов, лежащих в основе Agile-подхода:\n\n1. **Наивысший приоритет — удовлетворение потребностей заказчика** за счёт ранней и непрерывной поставки ценного программного обеспечения.\n2. **Принимайте изменения в требованиях**, даже на поздних стадиях разработки. Agile использует изменения как конкурентное преимущество.\n3. **Доставляйте рабочее ПО часто** — от нескольких недель до нескольких месяцев, отдавая предпочтение более коротким циклам.\n4. **Бизнес и разработчики должны работать вместе ежедневно** на протяжении всего проекта.\n5. **Стройте проекты вокруг мотивированных людей**. Доверяйте им, обеспечивайте поддержку и условия для работы.\n6. **Личное общение — самый эффективный способ передачи информации** внутри команды.\n7. **Работающий продукт — основной показатель прогресса**.\n8. **Agile поддерживает устойчивый темп разработки**. Спонсоры, разработчики и пользователи должны быть способны поддерживать этот темп неопределённо долго.\n9. **Постоянное внимание к техническому совершенству и качеству проектирования** повышает гибкость.\n10. **Простота — искусство не делать лишнего** — ключевой элемент.\n11. **Лучшие архитектуры, требования и дизайн появляются у самоорганизующихся команд**.\n12. **Команда регулярно анализирует, как стать более эффективной**, и корректирует своё поведение.\n\n## Адаптация Agile в образовательном контексте\n\nВ условиях обучения Agile проявляет себя как мощный инструмент развития soft skills и системного мышления. Вот как его ценности и принципы можно адаптировать:\n\n- **Командная работа и взаимодействие**: Студенты учатся работать в командах, проводить ежедневные стендапы, делегировать задачи и нести коллективную ответственность.\n- **Практико-ориентированное обучение**: Вместо теоретических заданий студенты создают работающие прототипы, получая обратную связь от преподавателей и «виртуальных заказчиков».\n- **Гибкость к изменениям**: Учебные проекты часто корректируются — Agile помогает студентам адаптироваться, не теряя мотивации.\n- **Развитие самоорганизации**: Роли Scrum-мастера, Product Owner и разработчиков позволяют каждому проявить лидерские качества и инициативу.\n- **Формирование культуры обратной связи**: Ретроспективы после каждой итерации учат студентов анализировать ошибки и улучшать процессы.\n\n## Где Agile работает, а где — нет?\n\n### ✅ Где Agile эффективен:\n- **Динамичные проекты с нестабильными требованиями** (например, стартапы, MVP-разработка).\n- **Команды с высокой вовлечённостью и квалификацией**.\n- **Проекты, где важна быстрая обратная связь от пользователей**.\n- **Образовательные среды**, где цель — не только результат, но и процесс обучения.\n\n### ❌ Где Agile может быть неуместен:\n- **Проекты с жёсткими регуляторными требованиями** (например, медицинское ПО, авиационные системы), где необходимы полная документация и строгий контроль изменений.\n- **Команды с низким уровнем самоорганизации** или отсутствием доверия.\n- **Проекты с фиксированным бюджетом и сроками**, где изменения не допускаются.\n- **Одиночная разработка**, где гибкие практики могут оказаться избыточными.\n\n## Заключение\n\nAgile — это не просто набор практик, а философия, ориентированная на людей, адаптивность и ценность продукта. В образовательном контексте он помогает студентам не только освоить технические навыки, но и развить критическое мышление, коммуникацию и ответственность. Однако, как и любая методология, Agile требует осознанного применения — важно понимать, когда он уместен, а когда стоит выбрать другой подход."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Scrum в деталях: роли, артефакты и события\n\nScrum — одна из наиболее популярных гибких (Agile) методологий управления проектами в IT. Она ориентирована на итеративную разработку, постоянную обратную связь и адаптацию к изменяющимся требованиям. Scrum структурирует процесс разработки с помощью чётко определённых **ролей**, **артефактов** и **событий**, что позволяет командам эффективно работать, быстро реагировать на изменения и регулярно поставлять рабочий продукт.\n\n#### Роли в Scrum\n\n1. **Product Owner (Владелец продукта)**\n   - Отвечает за максимизацию ценности продукта.\n   - Формулирует и управляет **Product Backlog** — списком требований к продукту, отсортированным по приоритету.\n   - Является главным контактным лицом для заинтересованных сторон (стейкхолдеров).\n   - Принимает или отклоняет результаты работы команды на этапе Sprint Review.\n\n2. **Scrum Master**\n   - Гарант соблюдения процесса Scrum.\n   - Помогает команде следовать правилам фреймворка, устраняет препятствия (блокеры).\n   - Фасилитирует Scrum-события (встречи), способствует самоорганизации команды.\n   - Не является менеджером, а выполняет роль коуча и наставника.\n\n3. **Development Team (Команда разработки)**\n   - Кросс-функциональная группа специалистов (программисты, тестировщики, аналитики и др.), которая непосредственно создаёт продукт.\n   - Самоорганизуется: сама решает, *как* и *кто* будет выполнять задачи.\n   - Обладает всеми навыками, необходимыми для доставки рабочего продукта на каждом спринте.\n   - Обычно состоит из 3–9 человек.\n\n#### Артефакты Scrum\n\n1. **Product Backlog**\n   - Динамичный, приоритизированный список всех функций, улучшений, исправлений и требований к продукту.\n   - Ведётся и обновляется Product Owner.\n   - Задачи формулируются в виде **пользовательских историй** (User Stories), например: «Как пользователь, я хочу войти в систему, чтобы получить доступ к своим данным».\n\n2. **Sprint Backlog**\n   - Подмножество задач из Product Backlog, выбранных командой для реализации в текущем спринте.\n   - Включает план выполнения: какие задачи, кто и как будет выполнять.\n   - Обновляется ежедневно в ходе работы.\n\n3. **Increment (Инкремент)**\n   - Рабочая, пригодная к релизу часть продукта, созданная за один спринт.\n   - Должна быть **смержена**, **протестирована** и соответствовать **Definition of Done** (DoD) — чёткому критерию завершённости.\n   - Каждый инкремент прибавляется к предыдущим, формируя итоговый продукт.\n\n#### События (Ceremonии) Scrum\n\n1. **Sprint (Спринт)**\n   - Основной временной цикл разработки, обычно длится от 1 до 4 недель (чаще — 2).\n   - В течение спринта команда работает над выбранными задачами, не меняя цели.\n   - Начинается планированием и заканчивается Review и Retrospective.\n\n2. **Sprint Planning (Планирование спринта)**\n   - Встреча в начале спринта, на которой команда совместно с Product Owner выбирает задачи из Product Backlog.\n   - Определяется цель спринта и формируется Sprint Backlog.\n   - Длительность — до 8 часов для 4-недельного спринта (пропорционально короче для более коротких спринтов).\n\n3. **Daily Stand-up (Ежедневная стоячая встреча)**\n   - Короткая встреча (не более 15 минут), проводимая каждый день в одно и то же время.\n   - Каждый участник отвечает на три вопроса:\n     - Что я сделал вчера?\n     - Что я планирую сделать сегодня?\n     - Есть ли у меня препятствия?\n   - Цель — синхронизация команды и выявление блокеров.\n\n4. **Sprint Review (Обзор спринта)**\n   - Встреча в конце спринта, на которой команда демонстрирует **инкремент** стейкхолдерам.\n   - Собирается обратная связь, которая может повлиять на следующие приоритеты в Product Backlog.\n   - Не является формальным утверждением продукта, а скорее презентацией и обсуждением.\n\n5. **Sprint Retrospective (Ретроспектива спринта)**\n   - Встреча после Review, но до начала следующего спринта.\n   - Команда анализирует, что прошло хорошо, что можно улучшить и как изменить процесс.\n   - Фокус на улучшении командной работы и процессов.\n   - Результат — конкретные действия по улучшению на следующий спринт.\n\n#### Заключение\n\nScrum — это не просто набор правил, а гибкая система, способствующая прозрачности, ответственности и постоянному улучшению. Понимание ролей, артефактов и событий позволяет командам эффективно управлять сложными проектами, адаптироваться к изменениям и регулярно поставлять ценность заказчику. В рамках учебного проекта применение Scrum помогает сформировать системное мышление и навыки командной разработки, востребованные в реальной IT-индустрии."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "markdown",
          "code": "```markdown\n# Практическое задание: Настройка Scrum-процесса для учебного проекта\n\n## Цель\nНастроить инструмент управления проектом (на выбор: Jira, Trello или GitHub Projects) для реализации учебного IT-проекта по методологии Scrum. Создать Product Backlog и сформулировать первые пользовательские истории с критериями принятия.\n\n---\n\n## Шаг 1: Выбор инструмента и настройка доски\n\n### Варианты:\n- **Jira** (рекомендуется для профессионального использования)\n- **Trello** (простой и наглядный интерфейс)\n- **GitHub Projects** (интеграция с кодом)\n\n### Настройка доски (Scrum-доска)\nСоздайте доску с колонками, соответствующими этапам спринта:\n- `Backlog`\n- `To Do`\n- `In Progress`\n- `Review / Testing`\n- `Done`\n\nТакже создайте отдельную вкладку/проект для **Product Backlog**.\n\n---\n\n## Шаг 2: Определение цели проекта\n\n**Проект:** Разработка веб-приложения *«Student Task Manager»* — система для студентов, где они могут:\n- Просматривать задания от преподавателей\n- Отмечать выполнение\n- Получать напоминания о дедлайнах\n- Просматривать статистику успеваемости\n\n---\n\n## Шаг 3: Формулировка пользовательских историй (User Stories)\n\nФормат: **Как [роль], я хочу [цель], чтобы [выгода]**\n\n### Примеры пользовательских историй:\n\n#### US-01: Просмотр заданий\n> **Как** студент, \n> **я хочу** видеть список всех заданий с дедлайнами, \n> **чтобы** планировать своё время.\n\n**Критерии принятия (Acceptance Criteria):**\n- [ ] Задания отображаются в хронологическом порядке\n- [ ] У каждого задания указаны: название, описание, дедлайн, статус\n- [ ] Статус может быть: «Не начато», «В процессе», «Выполнено»\n- [ ] Интерфейс адаптирован под мобильные устройства\n\n---\n\n#### US-02: Отметка выполнения задания\n> **Как** студент, \n> **я хочу** отмечать задание как выполненное, \n> **чтобы** отслеживать прогресс.\n\n**Критерии принятия:**\n- [ ] При нажатии на чекбокс статус задания меняется на «Выполнено»\n- [ ] Изменение статуса сохраняется в базе данных\n- [ ] После отметки задание перемещается в раздел «Выполнено» или помечается визуально\n\n---\n\n#### US-03: Получение напоминаний\n> **Как** студент, \n> **я хочу** получать уведомления за 24 часа до дедлайна, \n> **чтобы** не пропустить срок сдачи.\n\n**Критерии принятия:**\n- [ ] Система проверяет дедлайны каждые 24 часа\n- [ ] Уведомление приходит через интерфейс (всплывающее окно) и/или на email\n- [ ] Уведомление содержит название задания и дату дедлайна\n\n---\n\n#### US-04: Просмотр статистики\n> **Как** студент, \n> **я хочу** видеть диаграмму выполненных заданий за месяц, \n> **чтобы** оценивать свою продуктивность.\n\n**Критерии принятия:**\n- [ ] Диаграмма строится на основе данных о статусах заданий\n- [ ] Отображается количество выполненных заданий по дням недели\n- [ ] График обновляется автоматически при изменении статуса\n\n---\n\n## Шаг 4: Приоритизация и добавление в Product Backlog\n\nРазместите все пользовательские истории в **Product Backlog** в порядке приоритета:\n\n| ID  | Название                     | Приоритет | Оценка (в Story Points) |\n|-----|------------------------------|-----------|--------------------------|\n| US-01 | Просмотр заданий             | Высокий   | 3                        |\n| US-02 | Отметка выполнения задания   | Высокий   | 2                        |\n| US-03 | Получение напоминаний        | Средний   | 5                        |\n| US-04 | Просмотр статистики          | Средний   | 3                        |\n\n> **Примечание:** Оценка в Story Points — относительная мера сложности, согласованная командой.\n\n---\n\n## Шаг 5: Подготовка к первому спринту\n\nВыберите истории для первого спринта (например, US-01 и US-02), перенесите их в `Sprint Backlog` и разбейте на задачи:\n\n### Задачи для US-01:\n- [ ] Спроектировать макет страницы заданий (Figma)\n- [ ] Создать компонент TaskList в React\n- [ ] Подключить моковые данные\n- [ ] Написать тесты компонента\n\n### Задачи для US-02:\n- [ ] Добавить обработчик клика по чекбоксу\n- [ ] Обновить статус в хранилище (Redux / Context)\n- [ ] Сохранить изменения в локальное хранилище (localStorage)\n\n---\n\n## Результат задания\n- Настроена Scrum-доска в выбранном инструменте\n- Создан и приоритизирован Product Backlog\n- Сформулированы минимум 4 пользовательские истории с критериями принятия\n- Подготовлен Sprint Backlog для первого спринта\n\n> ✅ Отчёт предоставить в виде скриншотов доски + текстового файла с историями.\n```",
          "explanation": "Этот пример кода представлен в формате Markdown и может быть использован как инструкция для студентов. Он включает пошаговое руководство по настройке Scrum-процесса, созданию Product Backlog и формулировке пользовательских историй — ключевых навыков модуля. Пример ориентирован на реальный учебный проект, что способствует практическому применению Agile-практик."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Работа с требованиями: от идеи к пользовательской истории\n\nВ процессе разработки программного обеспечения ключевым этапом является корректная работа с требованиями. В гибких методологиях, таких как Scrum, традиционные технические задания заменяются **пользовательскими историями (user stories)** — краткими описаниями функциональности с точки зрения конечного пользователя.\n\n#### Шаблон пользовательской истории\n\nДля структурирования требований используется стандартный шаблон:\n\n> **«Как [роль], я хочу [действие], чтобы [цель]»**\n\nПример:\n> *«Как пользователь, я хочу войти в систему с помощью email и пароля, чтобы получить доступ к своему личному кабинету»*\n\nЭтот шаблон помогает команде:\n- Понять, **кто** является потребителем функции (роль),\n- Что именно он хочет сделать (действие),\n- И зачем — какую ценность это принесёт (цель).\n\n#### INVEST-критерии\n\nЧтобы пользовательская история была эффективной и пригодной к реализации в рамках итерации, она должна соответствовать **INVEST-критериям** — мнемоническому правилу, предложенному Биллом Вейктом (Bill Wake):\n\n| Буква | Критерий | Описание |\n|-------|---------|--------|\n| **I** | **Independent** (Независимая) | Истории должны быть как можно более независимыми друг от друга, чтобы можно было гибко менять приоритеты и порядок реализации. |\n| **N** | **Negotiable** (Обсуждаемая) | История — это не контракт, а приглашение к диалогу. Детали уточняются в процессе обсуждения с командой и заказчиком. |\n| **V** | **Valuable** (Ценная) | История должна приносить реальную ценность конечному пользователю или бизнесу. |\n| **E** | **Estimable** (Оцениваемая) | Команда должна быть способна оценить трудоёмкость реализации. Если история слишком расплывчата — её нужно разбить. |\n| **S** | **Small** (Маленькая) | История должна быть достаточно малой, чтобы уместиться в одну итерацию (спринт). Обычно — от нескольких часов до нескольких дней работы. |\n| **T** | **Testable** (Проверяемая) | Должны существовать критерии приёмки, позволяющие проверить, выполнена ли история.\n\n#### Приоритизация требований\n\nНе все требования одинаково важны. Для эффективного планирования используется приоритизация.\n\n**1. Метод MoSCoW**\n\nМетод позволяет разделить требования на четыре категории:\n\n- **M — Must have** (Обязательно): критически важные функции, без которых система неработоспособна.\n- **S — Should have** (Желательно): важные, но не критичные функции. Можно отложить.\n- **C — Could have** (Можно добавить): «хочу, но не обязательно». Реализуются при наличии времени и ресурсов.\n- **W — Won’t have (this time)** (Не будет сейчас): отложенные требования.\n\n**Пример:**\n- M: Возможность регистрации пользователя\n- S: Восстановление пароля по email\n- C: Вход через соцсети\n- W: Интеграция с мессенджером\n\n**2. Матрица Value vs Effort (Ценность vs Усилия)**\n\nГрафический метод, при котором каждая история оценивается по двум осям:\n- **Ценность для пользователя/бизнеса** (Value)\n- **Трудоёмкость реализации** (Effort)\n\nНа основе оценок истории попадают в один из квадрантов:\n- **Высокая ценность / низкие усилия** — «быстрые победы», реализуются в первую очередь.\n- **Высокая ценность / высокие усилия** — «крупные проекты», требуют планирования.\n- **Низкая ценность / низкие усилия** — «запасные», можно сделать при наличии времени.\n- **Низкая ценность / высокие усилия** — «электронные слоны», лучше избегать.\n\nЭтот подход помогает команде фокусироваться на максимальной отдаче при минимальных затратах.\n\n#### Заключение\n\nПереход от идеи к пользовательской истории — это не просто формулировка требования, а процесс осмысления ценности, оценки и приоритизации. Использование шаблона, INVEST-критериев и методов приоритизации позволяет команде эффективно управлять требованиями, избегать перегрузки и фокусироваться на действительно важных задачах."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "markdown",
          "code": "```markdown\n# Product Backlog для мини-проекта: Система управления задачами (Task Manager)\n\n## Описание проекта\nПростое веб-приложение для управления личными и командными задачами. Позволяет создавать, редактировать, отслеживать и архивировать задачи. Поддерживает роли пользователей, теги, приоритеты и сроки выполнения.\n\n---\n\n## Функциональные требования (User Stories)\n\n| ID | Пользовательская история | Приоритет | Оценка (в Story Points) |\n|----|--------------------------|----------|--------------------------|\n| US-01 | Как пользователь, я хочу зарегистрироваться в системе, чтобы иметь личный аккаунт. | Высокий | 3 |\n| US-02 | Как пользователь, я хочу войти в систему с логином и паролем, чтобы получить доступ к своим задачам. | Высокий | 2 |\n| US-03 | Как пользователь, я хочу создать новую задачу с названием, описанием, сроком и приоритетом. | Высокий | 5 |\n| US-04 | Как пользователь, я хочу редактировать или удалить свою задачу. | Средний | 3 |\n| US-05 | Как пользователь, я хочу помечать задачу как выполненную. | Средний | 2 |\n| US-06 | Как пользователь, я хочу фильтровать задачи по статусу, приоритету и сроку. | Средний | 5 |\n| US-07 | Как пользователь, я хочу добавлять теги к задачам для удобной группировки. | Низкий | 3 |\n| US-08 | Как администратор, я хочу приглашать пользователей в команду по email. | Средний | 5 |\n| US-09 | Как участник команды, я хочу назначать задачи другим членам команды. | Средний | 4 |\n| US-10 | Как пользователь, я хочу получать уведомления о приближающихся сроках задач. | Низкий | 3 |\n| US-11 | Как пользователь, я хочу экспортировать список задач в формате CSV. | Низкий | 3 |\n\n---\n\n## Нефункциональные требования\n\n| ID | Требование | Категория |\n|----|-----------|----------|\n| NFR-01 | Система должна загружаться за не более чем 2 секунды при нормальной нагрузке. | Производительность |\n| NFR-02 | Приложение должно поддерживать работу в браузерах: Chrome, Firefox, Safari (последние 2 версии). | Совместимость |\n| NFR-03 | Все пароли должны храниться в зашифрованном виде (например, bcrypt). | Безопасность |\n| NFR-04 | Интерфейс должен быть адаптирован под мобильные устройства (responsive design). | Юзабилити |\n| NFR-05 | Система должна обеспечивать резервное копирование данных раз в сутки. | Надёжность |\n| NFR-06 | Приложение должно поддерживать до 1000 активных пользователей одновременно. | Масштабируемость |\n| NFR-07 | Код приложения должен соответствовать стандартам PEP8 (если Python) или ESLint (если JavaScript). | Поддерживаемость |\n| NFR-08 | Должна быть реализована двухфакторная аутентификация (2FA) для администраторов. | Безопасность |\n\n---\n\n## Глоссарий\n- **Story Points** — относительная мера сложности задачи в Agile.\n- **User Story** — описание функциональности с точки зрения конечного пользователя.\n- **Product Backlog** — упорядоченный список всех требований к продукту, управляемый Product Owner.\n\n> **Примечание для студентов**: \n> - Приоритеты можно пересматривать на каждом Sprint Planning.\n> - Оценка в Story Points выполняется командой разработки на основе сложности, объёма и неопределённости.\n> - Нефункциональные требования должны учитываться при проектировании архитектуры и тестировании.\n```",
          "explanation": "Этот пример Product Backlog демонстрирует, как формализовать требования к мини-проекту в формате Agile. Включены типичные пользовательские истории (функциональные требования) и ключевые нефункциональные требования, соответствующие реальным практикам Scrum. Структура помогает студентам понять приоритезацию, оценку задач и важность учёта не только функциональности, но и качества системы."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Планирование спринта: оценка задач, составление Sprint Backlog и определение Sprint Goal\n\nПланирование спринта — это ключевое событие в рамках методологии Scrum, которое инициирует каждую итерацию разработки. Оно направлено на чёткое определение того, что команда будет реализовывать в течение спринта, и как именно это будет сделано. Процесс включает три основных компонента: **оценку задач**, **составление Sprint Backlog** и **определение Sprint Goal**.\n\n#### 1. Оценка задач: Story Points и Planning Poker\n\nВместо оценки задач в часах или днях, Scrum использует **story points** — относительную меру сложности, усилий, рисков и объёма работы, необходимых для выполнения пользовательской истории (user story).\n\n- **Story points** — это абстрактная единица, позволяющая сравнивать сложность задач между собой. Например, задача на 5 story points примерно в полтора раза сложнее, чем задача на 3 points.\n- Для оценки часто используется **масштаб Фибоначчи (1, 2, 3, 5, 8, 13, ...)**, так как он отражает неопределённость: чем сложнее задача, тем менее точной может быть оценка.\n\n**Planning Poker** — это техника коллективной оценки, в которой участвует вся команда разработки:\n- Каждый участник получает колоду карт с числами из ряда Фибоначчи.\n- Продакт-овнер кратко описывает user story.\n- Члены команды одновременно выкладывают карты с оценками.\n- Если оценки расходятся, проводится обсуждение для выявления различий в понимании задачи.\n- Процесс повторяется до достижения консенсуса.\n\nЭтот подход способствует вовлечённости, прозрачности и более точному пониманию требований.\n\n#### 2. Составление Sprint Backlog\n\n**Sprint Backlog** — это список задач, которые команда добровольно берёт на себя для выполнения в рамках текущего спринта. Он формируется на основе:\n- Продуктового бэклога (Product Backlog), отсортированного по приоритетам продакт-овнером.\n- Возможностей команды (её velocity — количества story points, которое она в среднем реализует за спринт).\n\nSprint Backlog включает:\n- Выбранные user stories.\n- Разбивку каждой истории на конкретные задачи (например, «разработать API-метод», «написать тесты», «сверстать интерфейс»).\n- Оценку задач в story points или часах (на усмотрение команды).\n- Ответственных исполнителей (не всегда, в зависимости от практик команды).\n\nВажно: **Sprint Backlog — это живой документ**, который обновляется в ходе спринта, но объём работ не увеличивается без согласования с продакт-овнером.\n\n#### 3. Определение Sprint Goal\n\n**Sprint Goal** — это краткое, понятное и мотивирующее описание цели спринта. Оно формулируется совместно командой и продакт-овнером и отвечает на вопрос: *«Зачем мы делаем эти задачи? Какой общий результат мы хотим достичь?»*\n\nПримеры Sprint Goal:\n- «Реализовать базовую функциональность оформления заказа, чтобы пользователи могли совершать покупки».\n- «Улучшить производительность системы авторизации и сократить время входа на 30%».\n\nSprint Goal выполняет несколько важных функций:\n- Объединяет команду вокруг общей цели.\n- Позволяет гибко адаптировать задачи в ходе спринта (если одна задача не успевается, её можно заменить другой, ведущей к той же цели).\n- Служит ориентиром при принятии решений.\n\n#### Заключение\n\nЭффективное планирование спринта — залог стабильного и предсказуемого прогресса в разработке. Использование story points и Planning Poker помогает команде лучше понимать объём работы, а Sprint Backlog и Sprint Goal обеспечивают прозрачность, фокус и ответственность. Эти практики формируют культуру совместной работы, доверия и непрерывного улучшения — ключевые ценности Agile и Scrum."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "plaintext",
          "code": "#################################################################\n# ПРАКТИЧЕСКОЕ ЗАДАНИЕ: Planning Poker и формирование Sprint Backlog\n# Модуль 3: Управление проектом и командная разработка (Agile/Scrum)\n#################################################################\n\n# КОНТЕКСТ:\n# Команда разрабатывает веб-приложение для управления личными задачами (аналог Trello).\n# Перед началом первого учебного спринта проводится Planning Poker с целью оценки задач\n# из Product Backlog и формирования Sprint Backlog.\n\n\n# ШАГ 1: Подготовка к Planning Poker\n\nУчастники:\n- Скрам-мастер: Алексей\n- Продуктовый владелец: Мария\n- Разработчики: Дмитрий, Елена, Сергей\n- Тестировщик: Ольга\n\nПравила игры:\n1. Используется шкала Фибоначчи: 1, 2, 3, 5, 8, 13, 20, 40, 100\n2. Каждый участник получает колоду карточек с числами.\n3. Продуктовый владелец описывает задачу без оценок.\n4. Все участники одновременно выкладывают карточку с оценкой.\n5. При расхождении мнений — обсуждение до консенсуса.\n6. Оценка фиксируется как согласованная команда.\n\n\n# ШАГ 2: Оценка задач методом Planning Poker\n\n# Задача 1: Регистрация нового пользователя\n- Описание: Реализовать форму регистрации с валидацией email, пароля (не менее 8 символов), отправкой подтверждения на email.\n- Нефункциональные требования: безопасность (хеширование пароля), время ответа < 1 сек.\n\nОценки команды:\n  Дмитрий: 8\n  Елена: 5\n  Сергей: 8\n  Ольга: 5\n  Алексей: 8\n\nОбсуждение:\n- Елена: «Валидация простая, бэкенд-логика стандартная — достаточно 5».\n- Дмитрий: «Интеграция с почтовым сервисом и обработка ошибок — это +3, итого 8».\n- Решение: согласована оценка — 8 (включает тестирование и документацию).\n\n\n# Задача 2: Авторизация пользователя (вход)\n- Описание: Форма входа, проверка учетных данных, создание сессии, JWT-токен.\n\nОценки:\n  Дмитрий: 5\n  Елена: 5\n  Сергей: 8\n  Ольга: 5\n  Алексей: 5\n\nОбсуждение:\n- Сергей: «JWT требует настройки middleware и refresh-токенов — может быть сложно».\n- Дмитрий: «Для учебного проекта refresh не обязателен, достаточно базовой реализации».\n- Решение: оценка — 5.\n\n\n# Задача 3: Создание новой задачи (To-Do)\n- Описание: Пользователь может создать задачу с названием, описанием, дедлайном, приоритетом.\n\nОценки:\n  Дмитрий: 3\n  Елена: 3\n  Сергей: 3\n  Ольга: 2\n  Алексей: 3\n\nОбсуждение:\n- Ольга: «Тестирование простое — достаточно 2».\n- Команда: «Оценка включает бэкенд, фронтенд, валидацию, тесты — 3 достаточно».\n- Решение: оценка — 3.\n\n\n# Задача 4: Просмотр списка задач\n- Описание: Отображение всех задач пользователя с фильтрацией по статусу (в работе, выполнено и т.д.).\n\nОценки:\n  Дмитрий: 5\n  Елена: 5\n  Сергей: 8\n  Ольга: 5\n  Алексей: 5\n\nОбсуждение:\n- Сергей: «Фильтрация на бэкенде + пагинация — может быть 8».\n- Елена: «Пагинация не требуется в этом спринте, фильтрация простая — 5».\n- Решение: оценка — 5.\n\n\n# Задача 5: Изменение статуса задачи (drag-and-drop)\n- Описание: Пользователь перетаскивает задачу между колонками (To Do, In Progress, Done).\n\nОценки:\n  Дмитрий: 8\n  Елена: 8\n  Сергей: 13\n  Ольга: 8\n  Алексей: 8\n\nОбсуждение:\n- Сергей: «Drag-and-drop на фронтенде + обновление бэкенда — это 13».\n- Дмитрий: «Используем готовую библиотеку (например, react-beautiful-dnd), поэтому 8».\n- Решение: оценка — 8.\n\n\n# ШАГ 3: Формирование Sprint Backlog\n\n# Допущение: Команда берёт задачи на общую сложность не более 30 очков за спринт (2 недели).\n\nSprint Backlog (Спринт 1):\n\n| ID  | Задача                                | Оценка (Story Points) |\n|-----|----------------------------------------|------------------------|\n| 1   | Регистрация нового пользователя       | 8                      |\n| 2   | Авторизация пользователя (вход)       | 5                      |\n| 3   | Создание новой задачи (To-Do)         | 3                      |\n| 4   | Просмотр списка задач                 | 5                      |\n| 5   | Изменение статуса задачи (drag-drop)  | 8                      |\n|     | **ИТОГО**                             | **29**                 |\n\n\n# ШАГ 4: Дополнительные действия\n\n- Все задачи разбиты на подзадачи в трекере (например, Jira или GitHub Projects).\n- Каждая задача получила заголовок, описание, acceptance criteria, теги (frontend/backend/testing).\n- Назначены ответственные (в рамках парного программирования или ротации).\n- Определён Definition of Done (DoD):\n   - Код прошёл ревью\n   - Написаны unit- и интеграционные тесты\n   - Обновлена документация\n   - Задача протестирована вручную\n   - Код слит в ветку develop\n\n\n# ВЫВОД\nМетод Planning Poker позволил команде:\n- Достичь общего понимания сложности задач.\n- Учесть мнения всех участников.\n- Сформировать реалистичный Sprint Backlog.\n- Заложить основу для прозрачного учёта прогресса.\n\nЭто практическое задание демонстрирует ключевые практики Scrum: командное принятие решений, итеративное планирование и управление объёмом работ.",
          "explanation": "Этот пример моделирует проведение Planning Poker в учебной команде. Включены реалистичные задачи, обсуждение оценок, формирование Sprint Backlog с учётом velocity. Показан процесс согласования, что развивает soft skills и понимание Agile-практик."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Проведение Daily Stand-up: что, как и зачем?\n\n**Daily Stand-up** (или ежедневный синхрон) — это короткая ежедневная встреча команды в рамках методологии Scrum, которая длится не более 15 минут. Её цель — синхронизировать работу участников, выявить текущие препятствия и обеспечить прозрачность прогресса в рамках спринта.\n\n#### Что происходит на Daily Stand-up?\nКаждый участник команды отвечает на три ключевых вопроса:\n1. **Что я сделал вчера?** — краткий отчёт о выполненных задачах.\n2. **Что я планирую сделать сегодня?** — обозначение текущих приоритетов.\n3. **Есть ли у меня препятствия (блокеры)?** — выявление проблем, мешающих продвижению.\n\nВажно: встреча проводится стоя (отсюда и название), чтобы поддерживать дисциплину времени и фокус.\n\n#### Зачем нужен Daily Stand-up?\n- Обеспечивает **прозрачность** процесса разработки.\n- Повышает **ответственность** каждого участника.\n- Позволяет быстро **выявлять риски и блокеры**.\n- Способствует **сплочённости команды** и совместному решению проблем.\n- Поддерживает **ритм спринта** и фокус на целях.\n\n#### Антипаттерны Daily Stand-up\n\n1. **Слишком длинные встречи**\n   - **Проблема**: встреча затягивается на 30–60 минут, теряется фокус.\n   - **Причина**: углубление в технические детали, обсуждение решений на месте.\n   - **Решение**: обсуждение сложных вопросов выносится за рамки встречи (в так называемые *встречи второго уровня*).\n\n2. **Отсутствие фокуса**\n   - **Проблема**: участники рассказывают общие фразы, не связанные с целями спринта.\n   - **Причина**: отсутствие подготовки или непонимание цели встречи.\n   - **Решение**: подготовка к встрече, фокус на задачах из бэклога спринта.\n\n3. **Монолог ведущего или одного участника**\n   - **Проблема**: один человек (часто менеджер или техлид) «рассказывает, как дела», а остальные молчат.\n   - **Решение**: каждый должен говорить о своей работе. Scrum Master следит за равным участием.\n\n4. **Отсутствие действий по блокерам**\n   - **Проблема**: препятствия озвучиваются, но не решаются.\n   - **Решение**: Scrum Master берёт на себя ответственность за устранение блокеров.\n\n#### Роль Scrum Master в фасилитации Daily Stand-up\n\nScrum Master — это **фасилитатор** встречи, а не ведущий или руководитель. Его задачи:\n- Обеспечить **соблюдение времени** (не более 15 минут).\n- Поддерживать **фокус на целях спринта**.\n- Следить за тем, чтобы **каждый участник высказался**.\n- Зафиксировать **блокеры** и взять их в работу.\n- Не допускать **технических дискуссий** на встрече.\n- Создать **безопасную среду**, где можно открыто говорить о проблемах.\n\n> **Важно**: Scrum Master не должен контролировать команду, а должен помогать ей быть эффективной. Его роль — служебная, а не управленческая.\n\n#### Итог\nDaily Stand-up — это не отчёт перед начальством, а инструмент **самоорганизации команды**. Когда он проводится правильно, он становится мощным катализатором прозрачности, ответственности и скорости разработки. Нарушение его принципов превращает встречу в формальность, что снижает доверие к процессу и замедляет прогресс."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Scrum-настройка для учебной команды: практическое руководство",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "Опишите, как вы распределили бы роли Scrum в учебной команде из 5 человек (разработчики, тестировщик, аналитик). Объясните, почему вы выбрали именно такое распределение, и какие риски могут возникнуть при совмещении ролей (например, когда один человек — и разработчик, и Scrum Master).",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Сформулируйте 3 пользовательские истории (User Stories) для функции \"Редактирование задачи\" в приложении для управления задачами. Для каждой истории укажите acceptance criteria и оцените сложность по шкале Фибоначчи (1, 2, 3, 5, 8). Обоснуйте свою оценку, учитывая необходимость валидации, обновления интерфейса и тестирования.",
            "options": [],
            "correct_answers": [],
            "points": 25
          },
          {
            "text": "Опишите, как вы организуете Product Backlog и Sprint Backlog в инструменте Jira или Trello. Какие колонки вы создадите, какие метки (labels) и типы задач (epic, story, task, bug) будете использовать? Приведите пример структуры доски и объясните, как она поддерживает прозрачность и управление потоком работ.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Представьте, что на третьем дне спринта один из разработчиков заболел, а задача по интеграции с почтовым сервисом (оценённая в 8 story points) осталась незавершённой. Как команда должна отреагировать в рамках Scrum? Опишите действия на ближайшем Daily Stand-up, возможные изменения в Sprint Backlog и роль Scrum Master в этой ситуации.",
            "options": [],
            "correct_answers": [],
            "points": 20
          },
          {
            "text": "Что такое Definition of Done (DoD) и почему он критически важен для успешного завершения спринта? Составьте пример DoD для задачи \"Создание новой задачи\" в веб-приложении, включив как технические, так и организационные критерии (например, код-ревью, тестирование, документация).",
            "options": [],
            "correct_answers": [],
            "points": 15
          }
        ]
      }
    },
    {
      "id": "26f5d65d-21bd-4ba8-a40f-0018e2fa9ebd",
      "title": "Модуль 4: Реализация, рефакторинг и технический долг",
      "description": "На этом модуле студенты переходят от проектирования к практической реализации программной системы. Акцент делается на качественной и устойчивой разработке: написании чистого кода, управлении техническим долгом, рефакторинге и интеграции автоматизированных практик. Студенты применяют полученные архитектурные решения на практике, реализуют функциональность на основе пользовательских историй и диаграмм, проводят рефакторинг кода, выявляют и устраняют кодовые запахи. Особое внимание уделяется последствиям накопления технического долга и его влиянию на долгосрочную поддержку ПО. Модуль завершается подготовкой к финальной интеграции и тестированию системы.",
      "learning_objectives": [
        "Реализовать систему на основе разработанной архитектуры и моделей (Use Case, диаграммы классов, последовательности).",
        "Применять практики чистого кода и паттерны проектирования при реализации.",
        "Выявлять и устранять кодовые запахи с помощью рефакторинга.",
        "Управлять техническим долгом: оценивать, документировать и приоритизировать его погашение.",
        "Интегрировать автоматизированные процессы CI/CD в учебный проект.",
        "Писать и запускать модульные и интеграционные тесты для обеспечения качества кода.",
        "Анализировать последствия технического долга на примерах реальных провалов IT-проектов."
      ],
      "order": 4,
      "content_blocks": [
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "from abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\nclass User:\n    \"\"\"\n    Модель пользователя системы.\n    Реализует базовую информацию о пользователе.\n    \"\"\"\n    def __init__(self, user_id: int, name: str, email: str):\n        self.user_id = user_id\n        self.name = name\n        self.email = email\n\n    def __repr__(self):\n        return f\"User({self.user_id}, {self.name}, {self.email})\"\n\n\nclass Order:\n    \"\"\"\n    Модель заказа. Соответствует диаграмме классов и последовательности.\n    Использует принципы чистого кода и инкапсуляции.\n    \"\"\"\n    def __init__(self, order_id: int, user: User):\n        self.order_id = order_id\n        self.user = user\n        self.items: List[OrderItem] = []\n        self.created_at = datetime.now()\n        self.status = \"pending\"\n\n    def add_item(self, item: 'OrderItem') -> None:\n        \"\"\"Добавляет товар в заказ.\"\"\"\n        self.items.append(item)\n\n    def calculate_total(self) -> float:\n        \"\"\"Рассчитывает общую стоимость заказа.\"\"\"\n        return sum(item.total_price() for item in self.items)\n\n    def set_status(self, status: str) -> None:\n        \"\"\"Устанавливает статус заказа.\"\"\"\n        self.status = status\n\n    def __repr__(self):\n        return f\"Order({self.order_id}, {self.user.name}, {self.status}, {self.calculate_total():.2f} руб.)\"\n\n\nclass Product:\n    \"\"\"\n    Модель товара в системе.\n    \"\"\"\n    def __init__(self, product_id: int, name: str, price: float):\n        self.product_id = product_id\n        self.name = name\n        self.price = price\n\n    def __repr__(self):\n        return f\"Product({self.product_id}, {self.name}, {self.price:.2f} руб.)\"\n\n\nclass OrderItem:\n    \"\"\"\n    Элемент заказа — связь между продуктом и количеством.\n    \"\"\"\n    def __init__(self, product: Product, quantity: int):\n        if quantity <= 0:\n            raise ValueError(\"Количество должно быть больше нуля.\")\n        self.product = product\n        self.quantity = quantity\n\n    def total_price(self) -> float:\n        \"\"\"Возвращает общую стоимость позиции.\"\"\"\n        return self.product.price * self.quantity\n\n    def __repr__(self):\n        return f\"OrderItem({self.product.name}, {self.quantity} шт., {self.total_price():.2f} руб.)\"\n\n\nclass PaymentProcessor(ABC):\n    \"\"\"\n    Абстрактный класс для обработки платежей — пример использования паттерна 'Стратегия'.\n    Позволяет легко расширять систему новыми способами оплаты.\n    \"\"\"\n    @abstractmethod\n    def process_payment(self, amount: float) -> bool:\n        pass\n\n\nclass CreditCardProcessor(PaymentProcessor):\n    \"\"\"Обработка оплаты через кредитную карту.\"\"\"\n    def process_payment(self, amount: float) -> bool:\n        print(f\"[Платёж] Оплата картой на сумму {amount:.2f} руб. обработана.\")\n        return True  # Имитация успешной оплаты\n\n\nclass OrderService:\n    \"\"\"\n    Сервис для управления заказами. Реализует бизнес-логику.\n    Соответствует диаграмме последовательности при оформлении заказа.\n    \"\"\"\n    def __init__(self, payment_processor: PaymentProcessor):\n        self.payment_processor = payment_processor\n        self.orders: List[Order] = []\n\n    def create_order(self, user: User) -> Order:\n        \"\"\"Создаёт новый заказ для пользователя.\"\"\"\n        order_id = len(self.orders) + 1\n        order = Order(order_id, user)\n        self.orders.append(order)\n        return order\n\n    def complete_order(self, order: Order) -> bool:\n        \"\"\"Завершает заказ: проверяет, оплачивает и меняет статус.\"\"\"\n        if not order.items:\n            print(\"[Ошибка] Нельзя завершить заказ без товаров.\")\n            return False\n\n        total = order.calculate_total()\n        if self.payment_processor.process_payment(total):\n            order.set_status(\"completed\")\n            print(f\"[Успех] Заказ {order.order_id} завершён.\")\n            return True\n        else:\n            order.set_status(\"failed\")\n            print(f\"[Ошибка] Оплата заказа {order.order_id} не удалась.\")\n            return False\n\n\n# Пример использования — демонстрация реализации на основе диаграмм\nif __name__ == \"__main__\":\n    # Создание пользователей и товаров\n    user = User(1, \"Анна Петрова\", \"anna@example.com\")\n    product1 = Product(101, \"Ноутбук\", 50000.0)\n    product2 = Product(102, \"Мышь\", 1500.0)\n\n    # Создание заказа\n    order_service = OrderService(CreditCardProcessor())\n    order = order_service.create_order(user)\n\n    # Добавление товаров\n    order.add_item(OrderItem(product1, 1))\n    order.add_item(OrderItem(product2, 2))\n\n    # Вывод информации о заказе\n    print(order)\n    for item in order.items:\n        print(f\"  - {item}\")\n\n    # Завершение заказа\n    order_service.complete_order(order)\n    print(order)",
          "explanation": "Этот пример демонстрирует практическую реализацию компонентов системы на основе архитектурных моделей:\n\n- **Диаграмма классов**: отражена через классы `User`, `Order`, `Product`, `OrderItem`, `OrderService` и абстрактный `PaymentProcessor`.\n- **Диаграмма последовательности**: логика метода `complete_order` соответствует последовательности действий при оформлении заказа (проверка, расчёт, оплата, изменение статуса).\n- **Паттерн проектирования**: использован паттерн *Стратегия* через `PaymentProcessor`, что позволяет гибко подключать разные способы оплаты.\n- **Чистый код**: соблюдены принципы именования, разделения ответственностей, документирования и обработки ошибок.\n- **Технологии**: Python с аннотацией типов, ABC для абстракций — современные практики разработки.\n\nКод готов к расширению (например, добавлению логирования, валидации, интеграции с БД) и может быть покрыт модульными тестами, что соответствует целям модуля по управлению техническим долгом и качеству реализации."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "from abc import ABC, abstractmethod\nfrom typing import List, Optional\n\n\nclass OrderStatus:\n    \"\"\"\n    Перечисление статусов заказа.\n    Использование класса вместо строковых литералов делает код более читаемым и безопасным.\n    \"\"\"\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\n\nclass Product:\n    \"\"\"\n    Модель товара.\n    Слабая связность: класс зависит только от базовых типов.\n    \"\"\"\n\n    def __init__(self, product_id: int, name: str, price: float) -> None:\n        self.product_id = product_id\n        self.name = name\n        self.price = price\n\n    def __repr__(self) -> str:\n        return f\"Product(id={self.product_id}, name='{self.name}', price={self.price})\"\n\n\nclass Order:\n    \"\"\"\n    Модель заказа. Хранит список товаров и текущий статус.\n    Следует принципу инкапсуляции: изменение статуса — через методы.\n    \"\"\"\n\n    def __init__(self, order_id: int) -> None:\n        self.order_id = order_id\n        self._items: List[Product] = []\n        self._status: str = OrderStatus.PENDING\n\n    def add_item(self, product: Product) -> None:\n        \"\"\"Добавляет товар в заказ.\"\"\"\n        if not isinstance(product, Product):\n            raise TypeError(\"Можно добавлять только объекты типа Product\")\n        self._items.append(product)\n\n    def get_total(self) -> float:\n        \"\"\"Возвращает общую стоимость заказа.\"\"\"\n        return sum(item.price for item in self._items)\n\n    def get_status(self) -> str:\n        \"\"\"Возвращает текущий статус заказа.\"\"\"\n        return self._status\n\n    def set_status(self, status: str) -> None:\n        \"\"\"\n        Устанавливает статус заказа с валидацией.\n        Следует принципу открытости/закрытости через расширение (enum).\n        \"\"\"\n        valid_statuses = [\n            OrderStatus.PENDING,\n            OrderStatus.CONFIRMED,\n            OrderStatus.SHIPPED,\n            OrderStatus.DELIVERED,\n            OrderStatus.CANCELLED,\n        ]\n        if status not in valid_statuses:\n            raise ValueError(f\"Недопустимый статус: {status}\")\n        self._status = status\n\n    def is_delivered(self) -> bool:\n        \"\"\"Проверяет, доставлен ли заказ.\"\"\"\n        return self._status == OrderStatus.DELIVERED\n\n\nclass NotificationService(ABC):\n    \"\"\"\n    Абстрактный класс для уведомлений.\n    Следует принципу зависимости от абстракций (D в SOLID).\n    \"\"\"\n\n    @abstractmethod\n    def send(self, recipient: str, message: str) -> None:\n        pass\n\n\nclass EmailNotificationService(NotificationService):\n    \"\"\"Реализация отправки уведомлений по email.\"\"\"\n\n    def send(self, recipient: str, message: str) -> None:\n        print(f\"[EMAIL] Отправлено на {recipient}: {message}\")\n\n\nclass SMSNotificationService(NotificationService):\n    \"\"\"Реализация отправки SMS-уведомлений.\"\"\"\n\n    def send(self, recipient: str, message: str) -> None:\n        print(f\"[SMS] Отправлено на {recipient}: {message}\")\n\n\nclass OrderProcessor:\n    \"\"\"\n    Обрабатывает заказы: подтверждение, отправка уведомлений.\n    Следует принципу единственной ответственности (S в SOLID).\n    Не зависит от конкретных реализаций уведомлений.\n    \"\"\"\n\n    def __init__(self, notification_service: NotificationService) -> None:\n        self.notification_service = notification_service\n\n    def confirm_order(self, order: Order, customer_email: str) -> None:\n        \"\"\"\n        Подтверждает заказ и отправляет уведомление.\n        Принцип инверсии зависимостей: используем абстракцию.\n        \"\"\"\n        if order.get_total() == 0:\n            raise ValueError(\"Нельзя подтвердить заказ без товаров\")\n\n        order.set_status(OrderStatus.CONFIRMED)\n        self.notification_service.send(\n            recipient=customer_email,\n            message=f\"Ваш заказ #{order.order_id} подтверждён! Сумма: {order.get_total():.2f} руб.\"\n        )\n\n    def ship_order(self, order: Order, customer_phone: str) -> None:\n        \"\"\"Отправляет заказ и уведомляет клиента.\"\"\"\n        if order.get_status() != OrderStatus.CONFIRMED:\n            raise ValueError(\"Заказ должен быть подтверждён перед отправкой\")\n\n        order.set_status(OrderStatus.SHIPPED)\n        self.notification_service.send(\n            recipient=customer_phone,\n            message=f\"Заказ #{order.order_id} отправлен. Ожидайте доставку.\"\n        )\n\n\nclass OrderRepository:\n    \"\"\"\n    Репозиторий для хранения заказов.\n    Выделен отдельно — следование принципу единственной ответственности.\n    Упрощает тестирование и замену хранилища.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._orders: dict[int, Order] = {}\n\n    def save(self, order: Order) -> None:\n        \"\"\"Сохраняет заказ.\"\"\"\n        self._orders[order.order_id] = order\n\n    def find_by_id(self, order_id: int) -> Optional[Order]:\n        \"\"\"Находит заказ по ID.\"\"\"\n        return self._orders.get(order_id)\n\n    def get_all(self) -> List[Order]:\n        \"\"\"Возвращает все заказы.\"\"\"\n        return list(self._orders.values())\n\n\ndef main() -> None:\n    \"\"\"\n    Главная функция — точка входа.\n    Демонстрирует использование всех компонентов.\n    \"\"\"\n    # Создаём товары\n    laptop = Product(product_id=1, name=\"Ноутбук\", price=75000.0)\n    mouse = Product(product_id=2, name=\"Мышь\", price=1500.0)\n\n    # Создаём заказ\n    order = Order(order_id=101)\n    order.add_item(laptop)\n    order.add_item(mouse)\n\n    # Выбираем способ уведомлений (можно легко заменить на SMS)\n    notifier = EmailNotificationService()\n    processor = OrderProcessor(notification_service=notifier)\n\n    # Обрабатываем заказ\n    try:\n        processor.confirm_order(order, customer_email=\"client@example.com\")\n        processor.ship_order(order, customer_phone=\"+79991234567\")\n    except ValueError as e:\n        print(f\"Ошибка при обработке заказа: {e}\")\n\n    # Сохраняем заказ\n    repo = OrderRepository()\n    repo.save(order)\n\n    # Проверяем результат\n    saved_order = repo.find_by_id(101)\n    if saved_order:\n        print(f\"Заказ #{saved_order.order_id} — статус: {saved_order.get_status()}\")\n        print(f\"Итоговая сумма: {saved_order.get_total():.2f} руб.\")\n\n\nif __name__ == \"__main__\":\n    main()",
          "explanation": "Этот пример демонстрирует **чистый код** в соответствии с принципами **SOLID**, правильным **именованием**, **структурой** и **комментариями**:\n\n- **S (Single Responsibility)**: Каждый класс отвечает за одну задачу (например, `OrderProcessor` — обработка заказов, `OrderRepository` — хранение).\n- **O (Open/Closed)**: Код открыт для расширения (например, можно добавить `PushNotificationService`), но закрыт для модификации.\n- **L (Liskov Substitution)**: Подклассы `EmailNotificationService` и `SMSNotificationService` могут заменять `NotificationService`.\n- **I (Interface Segregation)**: Абстракция `NotificationService` минимальна и сфокусирована.\n- **D (Dependency Inversion)**: `OrderProcessor` зависит от абстракции, а не от конкретных реализаций.\n\n**Именование**: Используются осмысленные имена (`OrderStatus`, `confirm_order`, `send`), без сокращений.\n\n**Структура**: Логичное разделение на классы, функции и модули. Код легко читать и расширять.\n\n**Комментарии**: Используются docstrings для описания назначения классов и методов, пояснения неочевидных решений. Нет избыточных комментариев.\n\nТакой подход снижает **технический долг**, упрощает **рефакторинг** и повышает **поддерживаемость** кода."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "from abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\nclass Task:\n    def __init__(self, task_id: int, title: str, description: str, status: str = \"новая\"):\n        self.task_id = task_id\n        self.title = title\n        self.description = description\n        self.status = status\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n\n    def update_status(self, new_status: str):\n        self.status = new_status\n        self.updated_at = datetime.now()\n\n    def __repr__(self):\n        return f\"Task({self.task_id}, '{self.title}', {self.status})\"\n\nclass TaskRepository(ABC):\n    @abstractmethod\n    def add_task(self, task: Task) -> None:\n        pass\n\n    @abstractmethod\n    def get_task(self, task_id: int) -> Optional[Task]:\n        pass\n\n    @abstractmethod\n    def list_tasks(self) -> List[Task]:\n        pass\n\n\nclass InMemoryTaskRepository(TaskRepository):\n    def __init__(self):\n        self._tasks = {}\n        self._current_id = 1\n\n    def add_task(self, task: Task) -> None:\n        task.task_id = self._current_id\n        self._tasks[self._current_id] = task\n        self._current_id += 1\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self._tasks.get(task_id)\n\n    def list_tasks(self) -> List[Task]:\n        return list(self._tasks.values())\n\nclass TaskService:\n    def __init__(self, repository: TaskRepository):\n        self.repository = repository\n\n    def create_task(self, title: str, description: str) -> Task:\n        if not title.strip():\n            raise ValueError(\"Заголовок задачи не может быть пустым\")\n        task = Task(task_id=0, title=title, description=description)\n        self.repository.add_task(task)\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.repository.get_task(task_id)\n\n    def list_all_tasks(self) -> List[Task]:\n        return self.repository.list_tasks()\n\n    def update_task_status(self, task_id: int, new_status: str) -> bool:\n        task = self.repository.get_task(task_id)\n        if not task:\n            return False\n        valid_statuses = [\"новая\", \"в работе\", \"завершена\", \"отменена\"]\n        if new_status not in valid_statuses:\n            raise ValueError(f\"Статус должен быть одним из: {valid_statuses}\")\n        task.update_status(new_status)\n        return True\n\n\nclass TaskApp:\n    def __init__(self, service: TaskService):\n        self.service = service\n\n    def run(self):\n        print(\"Добро пожаловать в систему управления задачами!\")\n        while True:\n            print(\"\\n1. Создать задачу\")\n            print(\"2. Просмотреть задачу\")\n            print(\"3. Просмотреть все задачи\")\n            print(\"4. Обновить статус задачи\")\n            print(\"5. Выйти\")\n            choice = input(\"Выберите действие: \")\n\n            if choice == \"1\":\n                title = input(\"Заголовок: \")\n                description = input(\"Описание: \")\n                try:\n                    task = self.service.create_task(title, description)\n                    print(f\"Задача создана: {task}\")\n                except ValueError as e:\n                    print(f\"Ошибка: {e}\")\n\n            elif choice == \"2\":\n                task_id = int(input(\"ID задачи: \"))\n                task = self.service.get_task(task_id)\n                if task:\n                    print(task)\n                else:\n                    print(\"Задача не найдена\")\n\n            elif choice == \"3\":\n                tasks = self.service.list_all_tasks()\n                for task in tasks:\n                    print(task)\n\n            elif choice == \"4\":\n                task_id = int(input(\"ID задачи: \"))\n                status = input(\"Новый статус: \")\n                try:\n                    if self.service.update_task_status(task_id, status):\n                        print(\"Статус обновлён\")\n                    else:\n                        print(\"Задача не найдена\")\n                except ValueError as e:\n                    print(f\"Ошибка: {e}\")\n\n            elif choice == \"5\":\n                print(\"До свидания!\")\n                break\n            else:\n                print(\"Неверный выбор\")\n\n\n# Пример использования на основе пользовательских историй\nif __name__ == \"__main__\":\n    # US1: Как пользователь, я хочу создавать задачи, чтобы отслеживать свои дела.\n    # US2: Как пользователь, я хочу просматривать список всех задач.\n    # US3: Как пользователь, я хочу обновлять статус задачи (новая → в работе → завершена).\n\n    repo = InMemoryTaskRepository()\n    service = TaskService(repo)\n    app = TaskApp(service)\n    app.run()\n",
          "explanation": "Этот код демонстрирует реализацию функциональности системы управления задачами на основе пользовательских историй (User Stories):\n\n- **Архитектура**: Применён принцип разделения ответственности (SOLID), использованы слои: сущности (Task), репозиторий (абстракция и реализация), сервисный слой и приложение.\n- **Чистый код**: Использованы типизированные аргументы, исключения вместо молчаливых ошибок, читаемые имена, документация.\n- **Реализация требований**:\n  - Создание задачи с валидацией\n  - Просмотр задач\n  - Обновление статуса с контролем допустимых значений\n- **Расширяемость**: Интерфейс `TaskRepository` позволяет легко заменить реализацию (например, на базу данных).\n- **Технический долг**: В текущей реализации отсутствуют модульные тесты и логирование — это пример управляемого технического долга, который можно приоритизировать позже.\n\nКод готов к интеграции в CI/CD и покрытию тестами."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "from abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):\n    \"\"\"Абстрактный интерфейс для обработки платежей.\"\"\"\n    @abstractmethod\n    def pay(self, amount: float) -> bool:\n        pass\n\nclass StripePaymentProcessor(PaymentProcessor):\n    \"\"\"Реализация платежей через Stripe.\"\"\"\n    def pay(self, amount: float) -> bool:\n        print(f\"[Stripe] Обработка платежа на сумму {amount}...\")\n        # Имитация успешной транзакции\n        return True\n\nclass PayPalPaymentProcessor(PaymentProcessor):\n    \"\"\"Реализация платежей через PayPal.\"\"\"\n    def pay(self, amount: float) -> bool:\n        print(f\"[PayPal] Обработка платежа на сумму {amount}...\")\n        # Имитация успешной транзакции\n        return True\n\nclass Order:\n    \"\"\"Класс, представляющий заказ.\"\"\"\n    def __init__(self, total: float):\n        self.total = total\n        self.is_paid = False\n\n    def complete_payment(self, processor: PaymentProcessor) -> None:\n        \"\"\"Завершить оплату с использованием переданного процессора.\"\"\"\n        if processor.pay(self.total):\n            self.is_paid = True\n            print(\"Заказ успешно оплачен.\")\n        else:\n            print(\"Ошибка при оплате заказа.\")\n\n\ndef main():\n    # Создаём заказ\n    order = Order(total=99.99)\n\n    # Выбираем способ оплаты (можно легко заменить на PayPal)\n    payment_processor = StripePaymentProcessor()\n    # payment_processor = PayPalPaymentProcessor()\n\n    # Завершаем оплату — зависимость инжектируется извне\n    order.complete_payment(payment_processor)\n\n\nif __name__ == \"__main__\":\n    main()",
          "explanation": "Этот пример демонстрирует **интеграцию компонентов системы** и **управление зависимостями** с использованием принципов SOLID и инверсии зависимостей (Dependency Inversion Principle).\n\n### Ключевые аспекты:\n- **Интерфейс `PaymentProcessor`** абстрагирует способ оплаты, позволяя легко подключать новые платёжные системы.\n- **Конкретные реализации** (`StripePaymentProcessor`, `PayPalPaymentProcessor`) зависят от абстракции, а не от конкретики.\n- **Класс `Order`** не знает деталей реализации платежа — он зависит только от интерфейса. Это упрощает тестирование, расширение и замену компонентов.\n- **Управление зависимостями** осуществляется через внедрение зависимости (Dependency Injection) — объект процессора передаётся в метод.\n\n### Практическая польза:\n- Легко добавить новый способ оплаты (например, Apple Pay) без изменения кода `Order`.\n- Упрощается модульное тестирование (можно использовать моки).\n- Снижается связанность компонентов, что уменьшает технический долг и упрощает рефакторинг.\n\nТакой подход типичен при интеграции внешних сервисов и является основой устойчивой и расширяемой архитектуры."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "# Введение в технический долг: примеры и пояснения\n\n\"\"\"\nТехнический долг (Technical Debt) — это метафора, описывающая компромиссы в разработке ПО,\nкогда выбирается быстрое, но неоптимальное решение для ускорения доставки функциональности.\nПозже это требует дополнительных усилий на исправление — «проценты» по долгу.\n\nОсновные виды технического долга:\n1. Кодовый долг — плохой код (дублирование, сложные условия, длинные методы).\n2. Архитектурный долг — нарушение принципов проектирования, жёсткая связанность.\n3. Документационный долг — отсутствие или устаревшая документация.\n\"\"\"\n\nclass OrderProcessor:\n    # Пример кодового технического долга: длинный, сложный метод\n    # с дублированием и нарушением принципа единственной ответственности\n\n    def process_order(self, order_data):\n        if not order_data:\n            print(\"Ошибка: данные заказа пусты\")\n            return False\n\n        # Валидация (дублируется в других методах)\n        if 'items' not in order_data or len(order_data['items']) == 0:\n            print(\"Ошибка: заказ не содержит товаров\")\n            return False\n        if 'customer_id' not in order_data:\n            print(\"Ошибка: не указан ID клиента\")\n            return False\n\n        # Логика обработки заказа (слишком много в одном методе)\n        total = 0\n        for item in order_data['items']:\n            if 'price' not in item or 'quantity' not in item:\n                print(\"Ошибка: некорректные данные товара\")\n                return False\n            total += item['price'] * item['quantity']\n\n        # Архитектурный долг: прямой вызов внешней системы без абстракции\n        # Жёсткая связанность с конкретной реализацией\n        if not self._send_to_payment_gateway(order_data['customer_id'], total):\n            print(\"Ошибка: оплата не прошла\")\n            return False\n\n        # Документационный долг: нет docstring, пояснений, комментариев\n        # Что делает этот блок? Почему именно так?\n        status = self._update_inventory(order_data['items'])\n        if not status:\n            print(\"Ошибка: не удалось обновить склад\")\n            return False\n\n        print(\"Заказ успешно обработан\")\n        return True\n\n    def _send_to_payment_gateway(self, customer_id, amount):\n        # Имитация вызова платежного шлюза\n        print(f\"[ПЛАТЕЖ] Отправка {amount} для клиента {customer_id}\")\n        return True  # Упрощение — всегда успешный платёж\n\n    def _update_inventory(self, items):\n        # Имитация обновления склада\n        for item in items:\n            print(f\"[СКЛАД] Списано {item['quantity']} единиц товара {item.get('id')}\")\n        return True\n\n\n# Пример использования (демонстрация последствий)\nif __name__ == \"__main__\":\n    processor = OrderProcessor()\n\n    # Тестовые данные\n    order = {\n        \"customer_id\": 123,\n        \"items\": [\n            {\"id\": 1, \"price\": 100, \"quantity\": 2},\n            {\"id\": 2, \"price\": 50, \"quantity\": 1}\n        ]\n    }\n\n    # Обработка заказа\n    result = processor.process_order(order)\n    print(f\"Результат обработки: {result}\\n\")\n\n    # Последствия технического долга:\n    # - Сложно тестировать (нет модульности)\n    # - Трудно изменять (высокая связанность)\n    # - Непонятно, как работает (нет документации)\n    # - Опасно вносить правки (риск сломать логику)\n\n    print(\"=== Анализ технического долга ===\")\n    print(\"1. Кодовый долг: метод process_order слишком длинный и нарушает принципы чистого кода.\")\n    print(\"2. Архитектурный долг: прямая зависимость от платежной системы без интерфейса.\")\n    print(\"3. Документационный долг: отсутствуют комментарии и пояснения к сложным блокам.\")\n\n    # Рекомендация: рефакторинг, внедрение паттернов, документирование\n",
          "explanation": "Этот код демонстрирует три основных вида технического долга:\n\n- **Кодовый долг**: метод `process_order` нарушает принцип единственной ответственности, содержит дублирование и избыточную сложность.\n- **Архитектурный долг**: прямая зависимость от внешних систем без использования абстракций (например, интерфейсов), что затрудняет замену или тестирование.\n- **Документационный долг**: отсутствуют docstring'и, комментарии и пояснения к логике, что снижает читаемость и поддерживаемость.\n\nПример показывает, как технический долг накапливается при стремлении быстро реализовать функционал, и какие последствия это влечёт: трудности при тестировании, изменении кода и передаче проекта новой команде. В реальных проектах такой код требует рефакторинга для снижения долгосрочных издержек."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "# Оценка и документирование технического долга в проекте\n# Пример: Матрица рисков и управление технической задолженностью через бэклог\n\nfrom enum import IntEnum\nfrom typing import List, Dict, Optional\nimport json\n\n\nclass DebtSeverity(IntEnum):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    CRITICAL = 4\n\n\nclass DebtType:\n    CODE = \"code_smell\"\n    DESIGN = \"design_debt\"\n    TEST = \"test_debt\"\n    DOC = \"documentation_debt\"\n    TECH_STACK = \"tech_stack_debt\"\n\n\nclass TechnicalDebtItem:\n    def __init__(\n        self,\n        id: str,\n        title: str,\n        description: str,\n        debt_type: str,\n        severity: DebtSeverity,\n        effort_days: float,\n        impact: str,\n        created_date: str,\n        resolved: bool = False,\n        resolution_date: Optional[str] = None\n    ):\n        self.id = id\n        self.title = title\n        self.description = description\n        self.debt_type = debt_type\n        self.severity = severity\n        self.effort_days = effort_days\n        self.impact = impact\n        self.created_date = created_date\n        self.resolved = resolved\n        self.resolution_date = resolution_date\n\n    def risk_score(self) -> float:\n        # Оценка риска: важность × усилия\n        return self.severity.value * self.effort_days\n\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"debt_type\": self.debt_type,\n            \"severity\": self.severity.name,\n            \"effort_days\": self.effort_days,\n            \"impact\": self.impact,\n            \"created_date\": self.created_date,\n            \"resolved\": self.resolved,\n            \"resolution_date\": self.resolution_date,\n            \"risk_score\": round(self.risk_score(), 2)\n        }\n\n\nclass TechnicalDebtBacklog:\n    def __init__(self):\n        self.items: Dict[str, TechnicalDebtItem] = {}\n\n    def add_item(self, item: TechnicalDebtItem):\n        self.items[item.id] = item\n\n    def get_high_risk_items(self, threshold: float = 6.0) -> List[TechnicalDebtItem]:\n        \"\"\"Возвращает элементы с риском выше порога\"\"\"\n        return [item for item in self.items.values() if item.risk_score() >= threshold]\n\n    def get_by_type(self, debt_type: str) -> List[TechnicalDebtItem]:\n        return [item for item in self.items.values() if item.debt_type == debt_type]\n\n    def get_unresolved(self) -> List[TechnicalDebtItem]:\n        return [item for item in self.items.values() if not item.resolved]\n\n    def generate_risk_matrix(self) -> Dict[str, List[Dict]]:\n        \"\"\"Группировка по уровню риска (средний, высокий, критический)\"\"\"\n        matrix = {\"low_risk\": [], \"medium_risk\": [], \"high_risk\": []}\n\n        for item in self.items.values():\n            score = item.risk_score()\n            if score < 4:\n                matrix[\"low_risk\"].append(item.to_dict())\n            elif score < 8:\n                matrix[\"medium_risk\"].append(item.to_dict())\n            else:\n                matrix[\"high_risk\"].append(item.to_dict())\n\n        return matrix\n\n    def report(self) -> str:\n        unresolved = len(self.get_unresolved())\n        total = len(self.items)\n        high_risk = len(self.get_high_risk_items())\n\n        return f\"Технический долг: {unresolved}/{total} нерешённых пунктов\\n\" \\\n               f\"Высокорисковых элементов: {high_risk}\\n\" \\\n               f\"Общее количество задолженностей: {total}\"\n\n    def export_to_json(self, filename: str):\n        data = {\n            \"metadata\": {\n                \"total_items\": len(self.items),\n                \"unresolved\": len(self.get_unresolved()),\n                \"generated_at\": \"2025-04-05T10:00:00Z\"\n            },\n            \"items\": [item.to_dict() for item in self.items.values()]\n        }\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, ensure_ascii=False)\n\n\n# Пример использования\nif __name__ == \"__main__\":\n    backlog = TechnicalDebtBacklog()\n\n    # Добавляем примеры технического долга\n    backlog.add_item(TechnicalDebtItem(\n        id=\"TD001\",\n        title=\"Сложная функция обработки заказа\",\n        description=\"Функция более 200 строк, нарушает принцип единственной ответственности\",\n        debt_type=DebtType.CODE,\n        severity=DebtSeverity.HIGH,\n        effort_days=2.5,\n        impact=\"Сложно тестировать и поддерживать\",\n        created_date=\"2025-03-01\"\n    ))\n\n    backlog.add_item(TechnicalDebtItem(\n        id=\"TD002\",\n        title=\"Отсутствие unit-тестов для модуля оплаты\",\n        description=\"Нет автоматизированных тестов для критического модуля\",\n        debt_type=DebtType.TEST,\n        severity=DebtSeverity.CRITICAL,\n        effort_days=3.0,\n        impact=\"Высокий риск регрессии при изменениях\",\n        created_date=\"2025-03-10\"\n    ))\n\n    backlog.add_item(TechnicalDebtItem(\n        id=\"TD003\",\n        title=\"Устаревшая версия Django (3.2)\",\n        description=\"Проект использует не поддерживаемую версию фреймворка\",\n        debt_type=DebtType.TECH_STACK,\n        severity=DebtSeverity.HIGH,\n        effort_days=5.0,\n        impact=\"Уязвимости безопасности, отсутствие обновлений\",\n        created_date=\"2025-02-15\"\n    ))\n\n    backlog.add_item(TechnicalDebtItem(\n        id=\"TD004\",\n        title=\"Недостаточная документация API\",\n        description=\"Отсутствуют примеры запросов и описания ошибок\",\n        debt_type=DebtType.DOC,\n        severity=DebtSeverity.MEDIUM,\n        effort_days=1.5,\n        impact=\"Замедляет интеграцию и onboarding новых разработчиков\",\n        created_date=\"2025-03-05\"\n    ))\n\n    # Генерация отчёта\n    print(backlog.report())\n\n    # Матрица рисков\n    risk_matrix = backlog.generate_risk_matrix()\n    print(\"\\n--- Матрица рисков технического долга ---\")\n    for level, items in risk_matrix.items():\n        print(f\"{level.upper()}: {len(items)} элементов\")\n\n    # Экспорт в JSON\n    backlog.export_to_json(\"technical_debt_backlog.json\")\n    print(\"\\nДанные экспортированы в technical_debt_backlog.json\")",
          "explanation": "Этот код демонстрирует практику оценки и документирования технического долга в проекте. Он реализует:\n\n- **Модель технической задолженности** с полями: ID, тип, серьёзность, усилия на исправление, влияние.\n- **Оценку риска** через матрицу: `риск = серьёзность × усилия`.\n- **Классификацию по уровням риска** (низкий, средний, высокий).\n- **Интеграцию с бэклогом** — задолженность отслеживается как часть задач разработки.\n- **Экспорт данных** для включения в отчёты или инструменты управления проектом (например, Jira).\n\nТакой подход помогает команде:\n- Видеть объём и приоритеты технического долга.\n- Принимать обоснованные решения о рефакторинге.\n- Планировать спринты с учётом погашения долга.\n- Избегать накопления критических рисков.\n\nПример соответствует целям модуля: управление техническим долгом, рефакторинг, интеграция в процесс разработки."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "from abc import ABC, abstractmethod\n\nclass Order:\n    def __init__(self, customer_type: str, items: list, total_amount: float):\n        self.customer_type = customer_type\n        self.items = items\n        self.total_amount = total_amount\n\n    # ПЛОХОЙ КОД: Кодовый запах — «Длинный метод» и «Условные операторы вместо полиморфизма»\n    def calculate_discount(self):\n        if self.customer_type == \"regular\":\n            if self.total_amount > 1000:\n                return self.total_amount * 0.05  # 5% скидка\n            else:\n                return 0\n        elif self.customer_type == \"premium\":\n            if self.total_amount > 500:\n                return self.total_amount * 0.1  # 10% скидка\n            else:\n                return self.total_amount * 0.05\n        elif self.customer_type == \"vip\":\n            base_discount = self.total_amount * 0.1\n            if self.total_amount > 2000:\n                return base_discount + (self.total_amount * 0.05)\n            return base_discount\n        return 0\n\n\n# РЕФАКТОРИНГ: Применение паттерна «Стратегия» и извлечение логики в отдельные классы\n\nclass DiscountStrategy(ABC):\n    @abstractmethod\n    def calculate_discount(self, total_amount: float) -> float:\n        pass\n\nclass NoDiscount(DiscountStrategy):\n    def calculate_discount(self, total_amount: float) -> float:\n        return 0\n\nclass RegularDiscount(DiscountStrategy):\n    def calculate_discount(self, total_amount: float) -> float:\n        return total_amount * 0.05 if total_amount > 1000 else 0\n\nclass PremiumDiscount(DiscountStrategy):\n    def calculate_discount(self, total_amount: float) -> float:\n        return total_amount * 0.1 if total_amount > 500 else total_amount * 0.05\n\nclass VIPDiscount(DiscountStrategy):\n    def calculate_discount(self, total_amount: float) -> float:\n        base_discount = total_amount * 0.1\n        bonus = total_amount * 0.05 if total_amount > 2000 else 0\n        return base_discount + bonus\n\nclass Customer:\n    def __init__(self, name: str, strategy: DiscountStrategy):\n        self.name = name\n        self.strategy = strategy\n\nclass OrderRefactored:\n    def __init__(self, customer: Customer, items: list, total_amount: float):\n        self.customer = customer\n        self.items = items\n        self.total_amount = total_amount\n\n    def calculate_discount(self) -> float:\n        return self.customer.strategy.calculate_discount(self.total_amount)\n\n    def final_price(self) -> float:\n        return self.total_amount - self.calculate_discount()\n\n\n# Пример использования\nif __name__ == \"__main__\":\n    # До рефакторинга\n    order_bad = Order(\"premium\", [\"laptop\", \"mouse\"], 1200)\n    print(f\"Скидка (старый код): {order_bad.calculate_discount()}\")\n\n    # После рефакторинга\n    premium_strategy = PremiumDiscount()\n    customer = Customer(\"Alice\", premium_strategy)\n    order_good = OrderRefactored(customer, [\"laptop\", \"mouse\"], 1200)\n    print(f\"Скидка (рефакторинг): {order_good.calculate_discount()}\")\n    print(f\"Итоговая цена: {order_good.final_price()}\")",
          "explanation": "В этом примере демонстрируется рефакторинг кода с устранением кодовых запахов:\n\n🔹 **Кодовые запахи в исходном коде**:\n- **Длинный метод** — `calculate_discount` выполняет много логики.\n- **Условные операторы вместо полиморфизма** — множественные `if-elif` по типу клиента.\n- **Дублирование логики** — расчёты скидок повторяются.\n\n🔹 **Применённые паттерны рефакторинга**:\n- **Извлечение классов** — вынесение стратегий скидок в отдельные классы.\n- **Замена условных операторов полиморфизмом** — использование паттерна «Стратегия».\n- **Инкапсуляция** — логика скидок отделена от класса `Order`.\n\n🔹 **Преимущества рефакторинга**:\n- Код стал расширяемым: легко добавить новый тип клиента.\n- Упрощено тестирование: можно тестировать каждую стратегию отдельно.\n- Устранён технический долг: изменение логики скидки не затрагивает другие части системы.\n\nЭтот пример иллюстрирует, как рефакторинг улучшает читаемость, тестируемость и поддерживаемость кода."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "```python\n# --- ПРИМЕР ДО РЕФАКТОРИНГА: ПЛОХОЙ КОД (с кодовыми 'запахами') ---\n\nclass OrderProcessor:\n    def process(self, order_data):\n        # Много вложенных условий, дублирование, нарушение принципов SRP и DRY\n        if order_data:\n            total = 0\n            for item in order_data['items']:\n                if item['category'] == 'electronics':\n                    total += item['price'] * 1.2  # НДС 20%\n                elif item['category'] == 'food':\n                    total += item['price'] * 1.05  # НДС 5%\n                else:\n                    total += item['price'] * 1.1  # НДС 10%\n\n            if total > 1000:\n                discount = total * 0.1\n                total -= discount\n\n            # Отправка email — логика в методе обработки заказа!\n            print(f\"Отправка email: Заказ на сумму {total} обработан\")\n\n            # Работа с базой — тоже здесь!\n            # Представим, что это 'сохранение в БД'\n            print(f\"Сохранение заказа {order_data['id']} в базу...\")\n\n            return total\n        return 0\n\n\n# Использование\norder = {\n    'id': 123,\n    'items': [\n        {'price': 500, 'category': 'electronics'},\n        {'price': 300, 'category': 'food'}\n    ]\n}\n\nprocessor = OrderProcessor()\nresult = processor.process(order)\nprint(f\"Итоговая сумма: {result}\\n\")\n\n\n# --- ПРИМЕР ПОСЛЕ РЕФАКТОРИНГА: ЧИСТЫЙ, ПОДДЕРЖИВАЕМЫЙ КОД ---\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Protocol\n\n\ndefault_tax_rate = 0.10\n\ntax_rates = {\n    'electronics': 0.20,\n    'food': 0.05\n}\n\n\nclass TaxCalculator:\n    @staticmethod\n    def calculate_tax(item_price: float, category: str) -> float:\n        rate = tax_rates.get(category, default_tax_rate)\n        return item_price * (1 + rate)\n\n\nclass DiscountService:\n    @staticmethod\n    def apply_discount(total: float) -> float:\n        return total * 0.9 if total > 1000 else total\n\n\nclass EmailService:\n    def send_confirmation(self, order_id: int, total: float):\n        print(f\"Отправка email: Заказ {order_id} на сумму {total} успешно обработан\")\n\n\nclass DatabaseService:\n    def save_order(self, order_id: int):\n        print(f\"Сохранение заказа {order_id} в базу...\")\n\n\nclass OrderItem:\n    def __init__(self, price: float, category: str):\n        self.price = price\n        self.category = category\n\nclass Order:\n    def __init__(self, order_id: int, items: List[OrderItem]):\n        self.id = order_id\n        self.items = items\n\n\nclass OrderProcessorRefactored:\n    def __init__(self, email_service: EmailService, db_service: DatabaseService):\n        self.email_service = email_service\n        self.db_service = db_service\n\n    def process(self, order: Order) -> float:\n        # 1. Рассчитываем сумму с налогами\n        total = sum(TaxCalculator.calculate_tax(item.price, item.category) for item in order.items)\n        \n        # 2. Применяем скидку\n        total = DiscountService.apply_discount(total)\n        \n        # 3. Уведомляем и сохраняем (выносим побочные эффекты)\n        self.email_service.send_confirmation(order.id, total)\n        self.db_service.save_order(order.id)\n        \n        return total\n\n\n# Использование после рефакторинга\nemail_service = EmailService()\ndb_service = DatabaseService()\nprocessor_refactored = OrderProcessorRefactored(email_service, db_service)\n\norder_refactored = Order(\n    order_id=123,\n    items=[\n        OrderItem(500, 'electronics'),\n        OrderItem(300, 'food')\n    ]\n)\n\nresult_refactored = processor_refactored.process(order_refactored)\nprint(f\"Итоговая сумма (после): {result_refactored}\")\n```",
          "explanation": "Этот пример демонстрирует рефакторинг кода от состояния с кодовыми запахами (божественный метод, нарушение SRP, дублирование, жёсткая привязка) к чистому, модульному и тестируемому решению.\n\n**Сравнение по ключевым метрикам:**\n\n🔹 **Читаемость**:\n- *До*: Логика смешана, трудно понять, что делает метод.\n- *После*: Каждый класс и метод имеет одну ответственность, код самодокументирован.\n\n🔹 **Тестируемость**:\n- *До*: Невозможно протестировать налоги, скидки или уведомления отдельно. Зависимости зашиты.\n- *После*: Можно легко писать юнит-тесты для `TaxCalculator`, `DiscountService` и мокать `EmailService`/`DatabaseService`.\n\n🔹 **Поддерживаемость**:\n- *До*: Добавление новой категории или изменения ставки налога требует правки в середине метода.\n- *После*: Новые категории добавляются в словарь `tax_rates`, логика не меняется.\n\n🔹 **Расширяемость**:\n- *После*: Легко добавить новые сервисы (логирование, валидацию), не изменяя существующий код (принцип Open/Closed).\n\n💡 **Вывод**: Рефакторинг превращает хрупкий, монолитный код в гибкую систему, соответствующую принципам SOLID и готовую к росту и автоматизированному тестированию."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "python",
          "code": "```python\n# Пример реализации модульных и интеграционных тестов с анализом покрытия кода\n# Проект: Управление библиотечной системой\n\n# --- Модель данных ---\n\nclass Book:\n    def __init__(self, isbn, title, author):\n        self.isbn = isbn\n        self.title = title\n        self.author = author\n        self.is_borrowed = False\n\n    def __repr__(self):\n        return f\"Book({self.isbn}, '{self.title}', '{self.author}')\"\n\n\nclass Library:\n    def __init__(self):\n        self.books = {}  # isbn -> Book\n\n    def add_book(self, book):\n        if book.isbn in self.books:\n            raise ValueError(\"Книга с таким ISBN уже существует\")\n        self.books[book.isbn] = book\n\n    def find_book(self, isbn):\n        return self.books.get(isbn)\n\n    def borrow_book(self, isbn):\n        book = self.find_book(isbn)\n        if not book:\n            raise ValueError(\"Книга не найдена\")\n        if book.is_borrowed:\n            raise ValueError(\"Книга уже взята\")\n        book.is_borrowed = True\n        return True\n\n    def return_book(self, isbn):\n        book = self.find_book(isbn)\n        if not book:\n            raise ValueError(\"Книга не найдена\")\n        if not book.is_borrowed:\n            raise ValueError(\"Книга не была взята\")\n        book.is_borrowed = False\n        return True\n\n\n# --- Модульные тесты (unit tests) ---\nimport unittest\n\nclass TestBook(unittest.TestCase):\n    def test_book_creation(self):\n        book = Book(\"123\", \"Python 101\", \"John Doe\")\n        self.assertEqual(book.title, \"Python 101\")\n        self.assertFalse(book.is_borrowed)\n\n\nclass TestLibrary(unittest.TestCase):\n    def setUp(self):\n        self.library = Library()\n        self.book = Book(\"978-0134685991\", \"Effective Java\", \"Joshua Bloch\")\n        self.library.add_book(self.book)\n\n    def test_add_book_duplicate_isbn(self):\n        with self.assertRaises(ValueError):\n            self.library.add_book(Book(\"978-0134685991\", \"Another Book\", \"Author\"))\n\n    def test_find_existing_book(self):\n        found = self.library.find_book(\"978-0134685991\")\n        self.assertEqual(found.title, \"Effective Java\")\n\n    def test_borrow_book_success(self):\n        result = self.library.borrow_book(\"978-0134685991\")\n        self.assertTrue(result)\n        self.assertTrue(self.book.is_borrowed)\n\n    def test_borrow_book_not_found(self):\n        with self.assertRaises(ValueError):\n            self.library.borrow_book(\"non-existent-isbn\")\n\n    def test_borrow_book_already_borrowed(self):\n        self.library.borrow_book(\"978-0134685991\")\n        with self.assertRaises(ValueError):\n            self.library.borrow_book(\"978-0134685991\")\n\n\n# --- Интеграционный тест ---\n\nclass TestLibraryIntegration(unittest.TestCase):\n    def test_full_book_lifecycle(self):\n        # Создание библиотеки и добавление книги\n        library = Library()\n        book = Book(\"978-0596009205\", \"Head First Design Patterns\", \"Freeman\")\n        library.add_book(book)\n\n        # Взятие книги\n        library.borrow_book(\"978-0596009205\")\n        self.assertTrue(book.is_borrowed)\n\n        # Возврат книги\n        library.return_book(\"978-0596009205\")\n        self.assertFalse(book.is_borrowed)\n\n        # Повторное взятие после возврата\n        library.borrow_book(\"978-0596009205\")\n        self.assertTrue(book.is_borrowed)\n\n\n# --- Запуск тестов и анализ покрытия (инструкции) ---\n# 1. Установите coverage: pip install coverage\n# 2. Запустите тесты с измерением покрытия:\n#    coverage run -m unittest discover\n# 3. Просмотр отчёта:\n#    coverage report\n# 4. Генерация HTML-отчёта:\n#    coverage html\n\n# Пример вывода coverage report:\n# Name            Stmts   Miss  Cover\n# -----------------------------------\n# library.py         30        0   100%\n\nif __name__ == '__main__':\n    unittest.main()\n```",
          "explanation": "Этот пример демонстрирует:\n\n- **Модульные тесты**: Проверяют отдельные компоненты (классы `Book` и `Library`) изолированно. Каждый метод тестируется на корректность поведения и обработку ошибок.\n- **Интеграционный тест**: Проверяет взаимодействие между объектами в сценарии полного жизненного цикла книги — добавление, взятие, возврат, повторное взятие.\n- **Покрытие кода**: С помощью инструмента `coverage.py` можно измерить, какой процент строк кода выполняется в тестах. Цель — достичь высокого покрытия (например, >90%), особенно для критической логики.\n\n**Практические рекомендации для студентов**:\n- Пишите тесты до или параллельно с реализацией (TDD).\n- Используйте `setUp()` для инициализации тестового окружения.\n- Проверяйте как штатные сценарии, так и исключения.\n- Интегрируйте `coverage` в CI/CD, чтобы отслеживать снижение покрытия.\n- Высокое покрытие — не гарантия качества, но низкое — сигнал о рисках технического долга."
        },
        {
          "content_type": "program_code",
          "ai_generated": true,
          "language": "yaml",
          "code": "# .github/workflows/ci-cd-pipeline.yml\n\nname: CI/CD Pipeline\n\non:\n  push:\n    branches:\n      - develop    # Запуск при пуше в ветку develop\n  pull_request:\n    branches:\n      - main       # Запуск при PR в main\n\njobs:\n  build-and-test:\n    name: Build and Test\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '18'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run linting\n      run: npm run lint\n\n    - name: Run unit tests with coverage\n      run: npm run test:unit:ci\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        token: ${{ secrets.CODECOV_TOKEN }}\n        file: ./coverage/lcov.info\n        flags: unittests\n\n    - name: Build application\n      run: npm run build\n\n    - name: Upload build artifact\n      uses: actions/upload-artifact@v3\n      with:\n        name: build-artifact\n        path: dist/\n\n  deploy-to-staging:\n    name: Deploy to Staging\n    needs: build-and-test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/develop'\n\n    environment:\n      name: staging\n      url: https://staging.myapp.example.com\n\n    steps:\n    - name: Download build artifact\n      uses: actions/download-artifact@v3\n      with:\n        name: build-artifact\n        path: dist/\n\n    - name: Deploy to staging server via SSH\n      uses: appleboy/ssh-action@v1.0.0\n      with:\n        host: ${{ secrets.STAGING_HOST }}\n        username: ${{ secrets.STAGING_USER }}\n        key: ${{ secrets.STAGING_SSH_KEY }}\n        script: |\n          cd /var/www/staging.myapp\n          rm -rf ./*\n          cp -r $GITHUB_WORKSPACE/dist/* .\n          echo \"Deployment to staging completed.\"\n\n  notify-on-failure:\n    name: Notify on Failure\n    needs: [build-and-test, deploy-to-staging]\n    if: failure()\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Send Slack notification\n      uses: slackapi/slack-github-action@v1.24.0\n      with:\n        channel_id: 'C0123456789'  # Канал для уведомлений\n        slack_bot_token: ${{ secrets.SLACK_BOT_TOKEN }}\n        message: '❌ Пайплайн CI/CD упал! Проверьте: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'\n",
          "explanation": "Этот GitHub Actions пайплайн реализует полный CI/CD процесс для веб-приложения:\n\n- **Триггеры**: запускается при пуше в `develop` или PR в `main`.\n- **Сборка и тестирование**: проверка кода, установка зависимостей, линтинг, запуск unit-тестов с покрытием, сборка бандла.\n- **Артефакты**: результат сборки сохраняется для дальнейшего использования.\n- **Развёртывание**: автоматически деплоится на staging-сервер через SSH при пуше в `develop`.\n- **Окружение**: staging помечено как защищённое окружение в GitHub.\n- **Оповещения**: при ошибках отправляется уведомление в Slack.\n\nПайплайн демонстрирует практики управления техническим долгом: автоматическое тестирование и линтинг предотвращают накопление кодовых запахов, а прозрачность процесса помогает вовремя выявлять и устранять проблемы."
        }
      ],
      "assignment": {
        "assignment_type": "github",
        "version": 0,
        "title": "Реализация ключевых компонентов системы с соблюдением чистого кода и архитектурных решений",
        "max_score": 100,
        "passing_score": 70,
        "repository_task": "https://github.com/your-org/module4-implementation-task",
        "repository_rules": "https://github.com/your-org/module4-implementation-task/blob/main/.github/CONTRIBUTING.md",
        "required_branch": "develop"
      }
    },
    {
      "id": "ec716a06-d6d0-4a13-9d03-35175990c284",
      "title": "Модуль 5: Тестирование, качество и безопасность ПО",
      "description": "В этом модуле студенты погружаются в ключевые аспекты обеспечения качества программного обеспечения: от проектирования тестов до внедрения практик непрерывной интеграции и обеспечения безопасности. На практических примерах обучающиеся освоят методы тестирования на разных уровнях, научатся оценивать качество кода и архитектуры, а также познакомятся с основными уязвимостями ПО и способами их предотвращения. Особое внимание уделено интеграции тестирования в Agile-процессы и использованию автоматизации для повышения надёжности и скорости разработки.",
      "learning_objectives": [
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
        "Применять методологии Agile (Scrum) для управления учебным проектом.",
        "Реализовать и протестировать систему, используя практики CI/CD и автоматизированного тестирования.",
        "Создать техническую документацию по ГОСТ и современным стандартам.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 5,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 5",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 5: Тестирование, качество и безопасность ПО] --> B[Тема 5.1: Уровни и типы тестирования ПО]\n    A --> C[Тема 5.2: Проектирование тестов и управление тестовой документацией]\n    A --> D[Тема 5.3: Автоматизированное тестирование и CI/CD]\n    A --> E[Тема 5.4: Метрики качества кода и рефакторинг]\n    A --> F[Тема 5.5: Основы безопасности ПО и анализ уязвимостей]\n    A --> G[Тема 5.6: Интеграция тестирования в Agile (Scrum) и отчётность]\n    A --> H[Итоговое задание: Комплексное тестирование учебного проекта]\n```",
          "explanation": "Диаграмма в формате Mermaid типа 'graph TD' (направленный граф сверху вниз) визуализирует структуру модуля 5, показывая его темы и итоговое задание как дочерние элементы основного модуля. Подходит для отображения иерархии содержания."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.1: Уровни и типы тестирования ПО\n\nТестирование программного обеспечения (ПО) — это систематический процесс проверки соответствия поведения системы её требованиям, выявления дефектов и обеспечения надёжности. Оно играет ключевую роль на всех этапах жизненного цикла разработки и является неотъемлемой частью обеспечения качества продукта. В зависимости от целей, глубины проверки и стадии разработки выделяют различные уровни и типы тестирования.\n\n#### Виды тестирования: модульное, интеграционное, системное, сквозное (end-to-end)\n\n1. **Модульное (юнит-тестирование)**\n   - **Цель**: Проверка отдельных компонентов или модулей кода (например, функций, классов) в изоляции.\n   - **Кто выполняет**: Разработчики.\n   - **Инструменты**: JUnit (Java), pytest (Python), NUnit (.NET) и др.\n   - **Пример**: Проверка корректности работы функции вычисления скидки в интернет-магазине.\n   - **Преимущества**: Быстрое выявление ошибок на ранних стадиях, упрощение отладки.\n\n2. **Интеграционное тестирование**\n   - **Цель**: Проверка взаимодействия между модулями или сервисами.\n   - **Подходы**: \"снизу вверх\", \"сверху вниз\", \"сборка по функциональности\".\n   - **Пример**: Проверка взаимодействия между модулем авторизации и модулем доступа к данным.\n   - **Сложности**: Требует настройки окружения и управления зависимостями.\n\n3. **Системное тестирование**\n   - **Цель**: Проверка всей системы в целом в условиях, максимально приближённых к реальным.\n   - **Охватывает**: Функциональные и нефункциональные требования.\n   - **Пример**: Полная проверка работы приложения после сборки всех компонентов.\n\n4. **Сквозное (end-to-end, E2E) тестирование**\n   - **Цель**: Имитация реальных сценариев использования системы от начала до конца.\n   - **Пример**: Тестирование процесса покупки товара — от выбора до подтверждения заказа.\n   - **Инструменты**: Selenium, Cypress, Playwright.\n   - **Особенность**: Проверяет не только логику, но и интеграцию с внешними системами (базы данных, API, платежные шлюзы).\n\n#### Функциональное и нефункциональное тестирование\n\n- **Функциональное тестирование**\n  - Проверяет, выполняет ли система заявленные функции.\n  - Основано на требованиях: что система *должна делать*.\n  - Виды: модульное, интеграционное, системное, приемочное.\n  - Пример: Проверка, что при вводе неверного пароля пользователь получает сообщение об ошибке.\n\n- **Нефункциональное тестирование**\n  - Проверяет *качество* работы системы.\n  - Включает:\n    - **Тестирование производительности** — проверка скорости, нагрузки, стабильности (например, с помощью JMeter).\n    - **Тестирование безопасности** — выявление уязвимостей (SQL-инъекции, XSS и др.).\n    - **Тестирование удобства использования (usability)** — оценка интуитивности интерфейса.\n    - **Тестирование совместимости** — работа на разных устройствах, ОС, браузерах.\n    - **Тестирование отказоустойчивости** — поведение системы при сбоях.\n\n#### Ручное и автоматизированное тестирование: плюсы и минусы\n\n| Критерий | Ручное тестирование | Автоматизированное тестирование |\n|---------|----------------------|-------------------------------|\n| **Гибкость** | Высокая — легко адаптироваться к изменениям | Низкая — требует обновления скриптов |\n| **Скорость выполнения** | Медленное, особенно при регрессии | Быстрое, особенно при повторных запусках |\n| **Точность** | Возможны ошибки из-за человеческого фактора | Высокая — скрипты выполняются одинаково |\n| **Стоимость** | Низкая на старте, но растёт при масштабировании | Высокая начальная, но окупается при долгосрочном использовании |\n| **Применимость** | Подходит для exploratory, usability-тестирования | Идеально для регрессионного, нагрузочного тестирования |\n\n**Рекомендация**: Использовать комбинированный подход — ручное тестирование на этапах анализа и исследования, автоматизацию — для регрессии и критически важных сценариев.\n\n#### Роль тестирования в жизненном цикле ПО\n\nТестирование интегрируется на всех этапах жизненного цикла:\n\n- **Анализ требований**: Формулирование тестовых сценариев на основе пользовательских историй.\n- **Проектирование**: Разработка тестовых планов и архитектуры тестирования.\n- **Разработка**: Написание юнит-тестов, интеграционных проверок.\n- **Тестирование**: Выполнение тестов, отчётность по дефектам.\n- **Внедрение и сопровождение**: Мониторинг, нагрузочное тестирование в продакшене, A/B-тесты.\n\nВ Agile и DevOps тестирование становится непрерывным процессом (CI/CD), где автоматизированные тесты запускаются при каждом коммите, обеспечивая быструю обратную связь.\n\n#### Практика: анализ тестового покрытия на примере учебного приложения\n\n**Цель**: Оценить, насколько полно код покрыт тестами.\n\n**Шаги**:\n1. Выбрать учебное приложение (например, веб-приложение для управления задачами).\n2. Запустить инструмент анализа покрытия (например, `coverage.py` для Python или JaCoCo для Java).\n3. Выполнить набор тестов (юнит- и интеграционных).\n4. Проанализировать отчёт:\n   - Какие классы/методы не покрыты?\n   - Есть ли сложные ветвления логики без проверок?\n5. Сформулировать рекомендации по улучшению покрытия.\n\n**Критерии качества покрытия**:\n- **Покрытие строк (line coverage)** — процент выполненных строк кода.\n- **Покрытие ветвлений (branch coverage)** — процент пройденных условных переходов.\n\n**Целевое значение**: 70–80% для большинства проектов, 90%+ — для критически важных систем.\n\n**Вывод**: Тестовое покрытие — это метрика, но не гарантия качества. Важно сочетать количественные показатели с качественным анализом сценариев.\n\n> **Итог**: Понимание уровней и типов тестирования позволяет строить эффективную стратегию обеспечения качества. Комбинирование ручных и автоматизированных подходов, интеграция тестирования в жизненный цикл и постоянный анализ покрытия — ключ к созданию надёжного и безопасного программного обеспечения."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.2: Проектирование тестов и управление тестовой документацией\n\nОбеспечение качества программного обеспечения невозможно без системного подхода к тестированию. Ключевым элементом этого процесса является **проектирование тестов** — этап, на котором формируются структурированные и эффективные тест-кейсы, способные выявить дефекты ещё до выхода продукта в продакшн. В этом разделе рассматриваются основные методы проектирования тестов, организация тестовой документации и практики управления ошибками.\n\n#### Методы проектирования тест-кейсов\n\nДля создания качественных тест-кейсов используются проверенные методы, позволяющие охватить максимальное количество сценариев с минимальными затратами. Наиболее распространённые из них:\n\n1. **Эквивалентное разбиение (Equivalence Partitioning)**\n   - Метод предполагает разделение входных данных на классы эквивалентности, где все значения в пределах одного класса ведут себя одинаково.\n   - Пример: если поле ввода принимает числа от 1 до 100, можно выделить три класса:\n     - Валидный: 1–100\n     - Невалидный (меньше): <1\n     - Невалидный (больше): >100\n   - Для тестирования достаточно проверить по одному значению из каждого класса.\n\n2. **Анализ граничных значений (Boundary Value Analysis)**\n   - Основан на идее, что ошибки чаще всего возникают на границах диапазонов.\n   - Продолжая предыдущий пример, тестируются значения: 0, 1, 100, 101.\n   - Этот метод дополняет эквивалентное разбиение и повышает вероятность обнаружения ошибок в условиях ветвления.\n\n3. **Таблицы решений (Decision Table Testing)**\n   - Используется для тестирования логики, зависящей от комбинации условий.\n   - Каждая строка таблицы — уникальный сценарий, а столбцы — условия и соответствующие действия.\n   - Пример: проверка доступа к системе в зависимости от логина, пароля и статуса аккаунта.\n   - Позволяет выявить пропущенные или противоречивые логические ветки.\n\nЭти методы позволяют систематизировать тест-дизайн, делая его более предсказуемым и воспроизводимым.\n\n#### Составление чек-листов и тест-планов\n\n- **Чек-лист** — это неформализованный, но практичный инструмент для ручного тестирования. Он содержит список действий, которые необходимо выполнить, чтобы проверить определённую функциональность. Чек-листы особенно полезны при регрессионном тестировании и exploratory testing.\n\n- **Тест-план** — документ, описывающий стратегию тестирования. Включает:\n  - Цели и объём тестирования\n  - Объекты тестирования\n  - Ресурсы и роли\n  - График работ\n  - Критерии входа и выхода\n  - Риски и меры их минимизации\n  - Инструменты и среды\n\nТест-план служит основой для координации команды тестирования и согласования ожиданий с заинтересованными сторонами.\n\n#### Управление багами: работа с баг-репортами, приоритизация, трекинг\n\nЭффективное управление дефектами включает несколько этапов:\n\n1. **Создание баг-репорта** — должен содержать:\n   - Заголовок\n   - Описание проблемы\n   - Шаги воспроизведения\n   - Ожидаемый и фактический результат\n   - Скриншоты/логи\n   - Окружение (ОС, браузер, версия ПО)\n   - Приоритет и серьёзность\n\n2. **Приоритизация** — определяется на основе:\n   - Влияния на пользователя (Severity)\n   - Частоты возникновения\n   - Сложности исправления\n   - Сроков релиза\n\n3. **Трекинг дефектов** — отслеживание статуса бага (New → Open → In Progress → Fixed → Verified → Closed) с помощью специализированных систем.\n\n#### Инструменты: Jira, TestRail (ознакомительно)\n\n- **Jira** (Atlassian) — гибкая система управления задачами и дефектами. Поддерживает:\n  - Создание и трекинг багов\n  - Интеграцию с тестовыми инструментами\n  - Дашборды и отчёты\n  - Работу в Agile-командах (Scrum, Kanban)\n\n- **TestRail** — специализированная платформа для управления тестовой документацией. Позволяет:\n  - Хранить тест-кейсы и тест-планы\n  - Запускать тесты и фиксировать результаты\n  - Генерировать отчёты по покрытию и прогрессу\n  - Интегрироваться с Jira и CI/CD-системами\n\nЭти инструменты способствуют прозрачности процессов и улучшают взаимодействие между разработчиками, тестировщиками и менеджерами.\n\n#### Практика: создание тест-кейсов для пользовательских историй из учебного проекта\n\nНа практике студенты применяют изученные методы для:\n\n- Анализа пользовательских историй (например, \"Как пользователь, я хочу войти в систему, чтобы получить доступ к личному кабинету\")\n- Выделения входных данных, условий и ожидаемых результатов\n- Разработки тест-кейсов с использованием эквивалентного разбиения и анализа граничных значений\n- Оформления тест-кейсов в виде таблиц или в TestRail\n- Составления чек-листов для ручного тестирования\n- Имитации обнаружения и регистрации багов в Jira\n\nЭтот практический блок позволяет закрепить теорию и подготовиться к реальным условиям разработки в команде.\n\n---\n\n> **Вывод**: Проектирование тестов и управление тестовой документацией — это не просто формальность, а важнейший элемент обеспечения качества ПО. Грамотное применение методов тест-дизайна и использование современных инструментов позволяют выявлять дефекты на ранних этапах, снижать стоимость исправлений и повышать надёжность конечного продукта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.3: Автоматизированное тестирование и CI/CD\n\nАвтоматизированное тестирование и непрерывная интеграция/непрерывное развертывание (CI/CD) являются ключевыми практиками современной разработки программного обеспечения. Они позволяют командам быстро и надежно доставлять изменения в код, минимизируя риски появления ошибок в продакшене.\n\n#### Принципы автоматизации тестирования\n\nАвтоматизация тестирования предполагает использование специализированных инструментов и скриптов для выполнения тестов без участия человека. Основные типы автоматизированных тестов:\n\n- **Unit-тесты (модульные тесты)** — проверяют отдельные компоненты или функции кода на корректность работы. Пишутся разработчиками, запускаются часто, быстро выполняются. Цель — убедиться, что каждый «строительный блок» приложения работает как ожидается.\n  \n- **Интеграционные тесты** — проверяют взаимодействие между модулями, сервисами или внешними системами (например, базами данных, API). Более медленные, чем unit-тесты, но критически важны для выявления ошибок на стыке компонентов.\n  \n- **UI-тесты (тесты пользовательского интерфейса)** — имитируют действия пользователя в браузере или приложении (например, клики, ввод данных). Помогают убедиться, что интерфейс работает корректно. Наиболее хрупкие и медленные, но важны для проверки пользовательского опыта.\n\nАвтоматизация особенно эффективна при регрессионном тестировании — проверке, что новые изменения не сломали существующий функционал.\n\n#### Фреймворки для автоматизированного тестирования\n\nВыбор фреймворка зависит от языка программирования проекта:\n\n- **Java / Kotlin**: JUnit — стандартный фреймворк для unit-тестирования. Поддерживает аннотации, параметризованные тесты, моки (с Mockito). Интегрируется с Maven/Gradle.\n\n- **Python**: PyTest — гибкий и мощный фреймворк с поддержкой фикстур, параметризации и плагинов. Подходит как для unit-, так и для интеграционных тестов.\n\n- **UI-тестирование**: Selenium — наиболее популярный инструмент для автоматизации браузеров. Позволяет писать скрипты на разных языках (Java, Python, JavaScript) и запускать их в Chrome, Firefox и других браузерах. Альтернативы: Playwright, Cypress (для веб-приложений на JavaScript).\n\n#### Интеграция тестов в пайплайн CI/CD\n\nCI/CD (Continuous Integration / Continuous Delivery & Deployment) — это практика автоматизации сборки, тестирования и развертывания приложения при каждом изменении кода.\n\n- **Непрерывная интеграция (CI)**: при каждом коммите в репозиторий запускается автоматическая сборка и набор тестов. Это позволяет быстро выявлять ошибки.\n\n- **Непрерывное развертывание (CD)**: после успешного прохождения тестов приложение автоматически разворачивается в тестовую или продакшен-среду.\n\nПопулярные платформы для CI/CD:\n\n- **GitHub Actions** — встроенный в GitHub инструмент. Пайплайн описывается в файле `.github/workflows/ci.yml`. Поддерживает множество готовых действий (actions) для тестирования, линтинга, деплоя.\n\n- **GitLab CI** — аналогичная система в GitLab. Конфигурация задается в `.gitlab-ci.yml`. Обеспечивает полный контроль над этапами пайплайна.\n\n#### Запуск тестов при каждом коммите, обработка результатов\n\nПри настройке CI/CD пайплайна:\n\n1. При пуше в ветку запускается workflow.\n2. Система CI клонирует репозиторий, устанавливает зависимости.\n3. Запускаются unit- и интеграционные тесты.\n4. При неудаче — уведомление команде (например, через Slack или email).\n5. При успехе — возможен деплой в staging/production.\n\nРезультаты тестов отображаются в интерфейсе CI-системы. Можно настроить обязательные проверки перед мержем (например, «тесты должны пройти»).\n\n#### Практика: настройка пайплайна с автоматическим запуском тестов\n\n**Задача**: настроить GitHub Actions для Python-проекта с PyTest.\n\n1. Создать файл `.github/workflows/ci.yml`:\n```yaml\nname: CI\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pytest\n          pip install -r requirements.txt\n      - name: Run tests\n        run: |\n          pytest tests/ -v --cov=myapp\n```\n\n2. Убедиться, что в репозитории есть:\n   - `requirements.txt`\n   - папка `tests/` с тестами\n   - файл `__init__.py` (если используется Python < 3.3)\n\n3. Запушить изменения — пайплайн запустится автоматически.\n\n4. Проверить статус выполнения в вкладке «Actions» на GitHub.\n\n**Результат**: теперь при каждом коммите будут запускаться тесты, и команда будет оперативно узнавать о проблемах.\n\n#### Заключение\n\nАвтоматизированное тестирование и CI/CD — не просто инструменты, а культура разработки, ориентированная на качество и скорость. Их внедрение позволяет сократить время выхода на рынок, повысить надежность ПО и улучшить взаимодействие в команде."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.4: Метрики качества кода и рефакторинг\n\n#### Понятие качества кода: читаемость, поддерживаемость, тестируемость\n\nКачество кода — это совокупность характеристик программного обеспечения, определяющих его надёжность, эффективность и удобство сопровождения. Выделяют три ключевых аспекта:\n\n- **Читаемость** — способность кода быть легко понятым разработчиком, не участвовавшим в его написании. Добиться этого помогают единообразный стиль форматирования, осмысленные имена переменных и функций, комментарии там, где это необходимо.\n- **Поддерживаемость** — возможность быстро и безопасно вносить изменения, исправлять ошибки и добавлять новые функции без риска нарушить существующую логику.\n- **Тестируемость** — способность кода быть легко протестированным. Хорошо структурированный, модульный код с чёткими интерфейсами и минимальной связанностью легче покрывать тестами.\n\nВысокое качество кода напрямую влияет на скорость разработки, количество багов и стоимость сопровождения.\n\n#### Метрики: покрытие кода тестами, цикломатическая сложность, дублирование кода\n\nДля объективной оценки качества кода используются количественные метрики:\n\n- **Покрытие кода тестами (Code Coverage)** — процент строк, ветвлений или путей выполнения, затронутых автоматическими тестами. Высокое покрытие (например, >80%) снижает риск регрессий, но не гарантирует отсутствие ошибок. Важно стремиться к осмысленному, а не формальному покрытию.\n- **Цикломатическая сложность (Cyclomatic Complexity)** — метрика, предложенная Томасом Маккейбом, измеряющая количество независимых путей выполнения в программе. Высокая сложность (например, >10 на метод) усложняет тестирование и понимание кода. Упрощение логики и декомпозиция помогают снизить её.\n- **Дублирование кода (Code Duplication)** — наличие одинаковых или почти одинаковых фрагментов в разных частях кодовой базы. Дублирование увеличивает объём поддержки и риск рассинхронизации при изменениях. Приемлемый порог — менее 5% дублирования.\n\nЭти метрики позволяют выявлять «узкие места» в коде и принимать обоснованные решения по его улучшению.\n\n#### Инструменты анализа: SonarQube, CodeClimate\n\nДля автоматического анализа метрик качества кода используются специализированные инструменты:\n\n- **SonarQube** — мощная платформа с открытым исходным кодом для непрерывного контроля качества кода. Поддерживает более 20 языков программирования, анализирует покрытие тестами, цикломатическую сложность, дублирование, уязвимости безопасности и стилистические ошибки. Интегрируется в CI/CD-пайплайны (например, через Jenkins, GitLab CI).\n- **CodeClimate** — облачный сервис для анализа качества кода, ориентированный на GitHub и GitLab. Предоставляет оценку «технического долга», выявляет дублирование, сложность и предлагает рекомендации. Удобен для команд, использующих облачные репозитории.\n\nОба инструмента помогают поддерживать высокий стандарт кода и выявлять проблемы на ранних этапах разработки.\n\n#### Принципы рефакторинга: выделение методов, устранение дублирования, улучшение именования\n\nРефакторинг — это процесс перестройки кода без изменения его внешнего поведения, направленный на улучшение его внутренней структуры. Основные принципы:\n\n- **Выделение методов (Extract Method)** — разбиение длинных и сложных функций на более мелкие, отвечающие за одну задачу. Это улучшает читаемость и повторное использование.\n- **Устранение дублирования (Remove Duplication)** — объединение повторяющихся фрагментов в отдельные методы или классы (принцип DRY — Don’t Repeat Yourself).\n- **Улучшение именования (Improve Naming)** — использование точных, описательных имён для переменных, методов и классов, отражающих их назначение.\n- **Упрощение условий** — замена сложных логических выражений на понятные и легко тестируемые.\n\nРефакторинг должен проводиться итерационно и сопровождаться тестами, чтобы избежать появления ошибок.\n\n#### Практика: анализ метрик своего проекта и выполнение рефакторинга\n\n**Задание для студентов:**\n\n1. Настройте инструмент анализа (SonarQube или CodeClimate) для своего учебного проекта.\n2. Запустите анализ и изучите отчёт: обратите внимание на модули с высокой цикломатической сложностью, низким покрытием тестами и наличием дублирования.\n3. Выберите 2–3 проблемных участка кода и выполните рефакторинг:\n   - Разбейте длинные методы.\n   - Устраните дублирование.\n   - Улучшите имена переменных и функций.\n4. Повторно запустите анализ и сравните метрики до и после изменений.\n5. Оформите отчёт с описанием изменений, их обоснованием и результатами улучшения метрик.\n\nЭта практика поможет закрепить навыки оценки и улучшения качества кода в реальных условиях разработки."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.5: Основы безопасности ПО и анализ уязвимостей\n\nОбеспечение безопасности программного обеспечения — критически важный аспект современной разработки. Уязвимости в коде могут привести к утечкам данных, компрометации систем и финансовым потерям. В этом разделе рассматриваются основные типы уязвимостей, принципы безопасного кодирования и инструменты для их выявления и устранения.\n\n#### Типичные уязвимости: OWASP Top 10\n\n**OWASP Top 10** — это рейтинг десяти наиболее критичных уязвимостей веб-приложений, поддерживаемый Open Web Application Security Project (OWASP). Он служит ориентиром для разработчиков и специалистов по безопасности. Ключевые уязвимости включают:\n\n1. **Инъекции (Injection)**\n   - Возникают, когда ненадёжные данные передаются в интерпретатор как часть команды или запроса.\n   - Пример: SQL-инъекция, когда злоумышленник вводит в поле формы SQL-код, который выполняется на сервере.\n   - Профилактика: использование параметризованных запросов, валидация входных данных, принцип минимальных привилегий.\n\n2. **Межсайтовый скриптинг (XSS, Cross-Site Scripting)**\n   - Позволяет внедрить вредоносные скрипты в веб-страницы, просматриваемые другими пользователями.\n   - Типы: отражённый, хранящийся, DOM-ориентированный XSS.\n   - Профилактика: экранирование выходных данных, использование Content Security Policy (CSP), валидация входа.\n\n3. **Подделка межсайтовых запросов (CSRF, Cross-Site Request Forgery)**\n   - Злоумышленник заставляет авторизованного пользователя выполнить нежелательное действие на веб-сайте.\n   - Пример: автоматическая отправка формы перевода средств без ведома пользователя.\n   - Профилактика: использование CSRF-токенов, проверка заголовка `Origin`/`Referer`, SameSite-атрибуты куки.\n\n4. **Небезопасная аутентификация**\n   - Слабые механизмы аутентификации и управления сессиями позволяют перехватывать учётные данные или сессии.\n   - Примеры: хранение паролей в открытом виде, отсутствие двухфакторной аутентификации, предсказуемые токены сессии.\n   - Профилактика: хранение хэшей паролей (например, с помощью bcrypt), использование безопасных протоколов (HTTPS), ограничение попыток входа.\n\nДругие уязвимости из OWASP Top 10 включают небезопасное хранение данных, уязвимости в компонентах с открытым исходным кодом, недостаточную логику безопасности и т.д.\n\n#### Принципы безопасного кодирования\n\nДля минимизации рисков при разработке следует придерживаться следующих принципов:\n\n- **Принцип наименьших привилегий**: каждый компонент должен работать с минимально необходимыми правами.\n- **Защита по глубине (Defence in Depth)**: использование нескольких уровней защиты.\n- **Позитивная проверка (whitelist)**: разрешать только известные безопасные данные, а не блокировать известные вредоносные.\n- **Ошибки по умолчанию**: при сбое система должна переходить в безопасное состояние.\n- **Простота дизайна**: сложные системы труднее анализировать и защищать.\n- **Полнота аудита**: все критические операции должны логироваться.\n\n#### Инструменты статического анализа безопасности (SAST)\n\n**SAST (Static Application Security Testing)** — метод анализа исходного кода на наличие уязвимостей без его выполнения. Основные инструменты:\n\n- **SonarQube**\n  - Поддерживает множество языков (Java, C#, JavaScript, Python и др.).\n  - Обнаруживает не только уязвимости, но и проблемы с качеством кода (дублирование, сложность, антипаттерны).\n  - Интегрируется в CI/CD-пайплайны.\n\n- **Bandit**\n  - Инструмент для анализа Python-кода.\n  - Выявляет типичные уязвимости: использование небезопасных функций (`pickle`, `eval`), незашифрованные пароли, слабое шифрование.\n  - Запускается через командную строку: `bandit -r my_project/`.\n\n- **ESLint с security-плагинами**\n  - Плагины: `eslint-plugin-security`, `eslint-plugin-no-unsafe-innerhtml`.\n  - Обнаруживает потенциальные XSS, использование `eval`, небезопасные операции с DOM.\n  - Пример правила: `detect-object-injection`, `no-dynamic-require`.\n\n#### Практика: поиск и устранение уязвимостей в учебном приложении\n\n**Цель**: выявить и исправить уязвимости в учебном веб-приложении (например, на Flask или Express.js).\n\n**Шаги выполнения**:\n\n1. **Анализ кода с помощью SAST**:\n   - Запустите Bandit (для Python) или ESLint (для JavaScript).\n   - Изучите отчёт: найдите предупреждения о потенциальных уязвимостях.\n\n2. **Поиск уязвимостей**:\n   - Проверьте формы на наличие XSS (введите `<script>alert(1)</script>`).\n   - Проверьте возможность SQL-инъекции (введите `' OR 1=1 --` в поле логина).\n   - Убедитесь, что отсутствуют CSRF-токены в формах.\n\n3. **Устранение уязвимостей**:\n   - Используйте параметризованные запросы вместо конкатенации строк.\n   - Экранируйте вывод на страницу (например, с помощью `escape()` в Jinja2 или `DOMPurify` в JS).\n   - Добавьте CSRF-токены в формы.\n   - Храните пароли с помощью хэширования (bcrypt, scrypt).\n\n4. **Повторный анализ**:\n   - Перезапустите SAST-инструменты.\n   - Убедитесь, что количество предупреждений сократилось.\n\n**Результат**: приложение становится устойчивым к основным атакам, а код соответствует стандартам безопасного программирования.\n\n#### Заключение\n\nБезопасность ПО — не опция, а обязательная часть разработки. Раннее выявление уязвимостей с помощью OWASP Top 10, соблюдение принципов безопасного кодирования и использование SAST-инструментов позволяют существенно снизить риски. Интеграция этих практик в Agile-процессы и CI/CD обеспечивает непрерывную защиту на всех этапах жизненного цикла ПО."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Тема 5.6: Интеграция тестирования в Agile (Scrum) и отчётность\n\nВ условиях динамичной разработки по методологии Agile, особенно в рамках фреймворка Scrum, тестирование перестаёт быть отдельной фазой в конце цикла и становится неотъемлемой частью каждого спринта. Это требует глубокой интеграции процессов обеспечения качества (QA) в повседневную деятельность команды.\n\n#### Роль QA в Scrum-команде\n\nСпециалист по тестированию (QA) в Scrum-команде — это полноценный участник процесса разработки, а не внешний контролёр. Его ключевые функции включают:\n\n- **Раннее вовлечение**: QA участвует в планировании спринта, обсуждении пользовательских историй и критериев принятия (acceptance criteria), что позволяет выявить потенциальные проблемы на этапе проектирования.\n- **Формулирование тестовых сценариев**: совместно с Product Owner и разработчиками QA помогает детализировать требования и определяет, как будет проверяться выполнение задачи.\n- **Автоматизация тестов**: QA способствует внедрению автоматизированных тестов (модульных, интеграционных, UI), интегрируемых в CI/CD-пайплайн.\n- **Обеспечение качества на всех уровнях**: QA отвечает не только за функциональное тестирование, но и за нефункциональные аспекты — производительность, безопасность, удобство использования.\n\n#### Планирование тестирования в спринтах\n\nТестирование должно быть заложено в каждый элемент спринта:\n\n- **На планировании спринта (Sprint Planning)**: тестовые задачи включаются в бэклог спринта наравне с разработкой. Это может быть как тестирование новых фич, так и рефакторинг тестов, исправление багов, настройка окружения.\n- **Ежедневные стендапы (Daily Scrum)**: QA делится статусом тестирования, сообщает о найденных дефектах, блокерах и готовности функционала.\n- **Ревью спринта (Sprint Review)**: демонстрируется не только реализованный функционал, но и его качество — покрытие тестами, количество критических багов, результаты нагрузочного тестирования.\n\n#### Definition of Done: включение тестов и качества кода\n\n**Definition of Done (DoD)** — это чек-лист, который определяет, когда задача считается завершённой. Для обеспечения стабильного качества DoD должен включать:\n\n- Код прошёл код-ревью.\n- Написаны и пройдены модульные и интеграционные тесты (с требуемым покрытием, например, 80%).\n- Автоматические тесты проходят в CI/CD.\n- Код соответствует стандартам форматирования и архитектурным правилам (проверено линтерами и статическим анализом).\n- Документация обновлена.\n- Функционал протестирован вручную (если необходимо) и соответствует acceptance criteria.\n\nБез выполнения всех пунктов DoD задача не считается завершённой и не переходит в «Готово».\n\n#### Отчётность по качеству: дашборды, метрики, баг-бёрны\n\nДля прозрачности и принятия решений на ретроспективе используются следующие инструменты:\n\n- **Дашборды качества**: визуализация ключевых метрик в реальном времени (например, в Jira, GitLab, Grafana):\n  - Покрытие кода тестами.\n  - Количество активных багов по приоритетам.\n  - Время жизни дефекта (от обнаружения до закрытия).\n  - Процент прохождения автоматических тестов.\n\n- **Баг-бёрн-даун (Bug Burn-down)**: график, отображающий динамику обнаружения и закрытия багов в спринте. Помогает оценить стабильность системы и нагрузку на команду.\n\n- **Метрики качества**:\n  - **Defect Density** — количество дефектов на единицу кода (например, на 1000 строк).\n  - **Test Execution Pass Rate** — процент успешных тестов.\n  - ** escaped defects** — количество багов, обнаруженных после релиза.\n\n#### Практика: подготовка отчёта о качестве ПО для ретроспективы спринта\n\n**Цель**: Предоставить команде и заинтересованным сторонам объективную оценку качества на ретроспективе.\n\n**Структура отчёта**:\n\n1. **Общая статистика спринта**:\n   - Количество реализованных пользовательских историй.\n   - Объём изменённого кода.\n\n2. **Метрики качества**:\n   - Покрытие кода тестами: 78% (цель — 80%).\n   - Количество новых багов: 12 (из них 3 — критических).\n   - Баг-бёрн-даун: рост багов в первой половине спринта, стабилизация во второй.\n\n3. **Проблемы и риски**:\n   - Задержки в тестировании из-за неготовности тестового окружения.\n   - Высокая плотность дефектов в модуле авторизации.\n\n4. **Рекомендации**:\n   - Уделить внимание рефакторингу модуля авторизации.\n   - Автоматизировать развертывание тестового окружения.\n   - Добавить нагрузочное тестирование перед следующим релизом.\n\n5. **Выводы**:\n   - Качество кода в целом стабильное, но требует улучшения в отдельных модулях.\n   - Необходимо усилить проактивное тестирование на ранних этапах.\n\nТакой отчёт способствует непрерывному улучшению процессов и повышению ответственности всей команды за качество продукта."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "### Итоговое задание: Комплексное тестирование учебного проекта\n\nВ рамках модуля 5 студенты подводят итог проделанной работе, фокусируясь на всестороннем обеспечении качества программного обеспечения. Данное итоговое задание призвано интегрировать все полученные знания и навыки в единую практико-ориентированную задачу, отражающую реальные процессы в современных IT-командах.\n\n#### Цель задания\n\nЦель — продемонстрировать способность разрабатывать и поддерживать высококачественное, надёжное и безопасное программное обеспечение с использованием современных методов тестирования, автоматизации и контроля качества на всех этапах жизненного цикла.\n\n---\n\n### Этапы выполнения задания\n\n#### 1. **Разработка полного набора тест-кейсов**\n\nСтуденты должны создать полный комплект тест-кейсов, охватывающий:\n\n- **Функциональные требования** (на основе Use Case и пользовательских историй)\n- **Позитивные и негативные сценарии**\n- **Граничные значения и исключительные ситуации**\n- **Тесты для всех уровней**: модульное (unit), интеграционное, сквозное (end-to-end)\n\nФормат тест-кейсов: структурированный (ID, название, предусловия, шаги, ожидаемый результат, приоритет). Рекомендуется использовать табличное представление или специализированные инструменты (например, TestRail, Xray, или Markdown-документы).\n\n#### 2. **Настройка CI/CD с автоматическими тестами**\n\nНеобходимо настроить конвейер непрерывной интеграции и доставки (CI/CD), включающий:\n\n- Автоматическую сборку проекта\n- Запуск unit- и интеграционных тестов при каждом коммите\n- Проверку покрытия кода тестами (с использованием инструментов: например, JaCoCo, Istanbul, Coverage.py)\n- Блокировку мержа в основную ветку при падении тестов или снижении покрытия ниже заданного порога\n\nПоддерживаемые платформы: GitHub Actions, GitLab CI, Jenkins, CircleCI и др.\n\n#### 3. **Проведение рефакторинга на основе метрик качества**\n\nНа основе анализа метрик кода студенты проводят рефакторинг:\n\n- **Метрики для анализа**:\n  - Цикломатическая сложность (Cyclomatic Complexity)\n  - Плотность комментариев\n  - Дублирование кода\n  - Длина методов и классов\n  - Связность и зацепление (coupling & cohesion)\n\nИнструменты: SonarQube, ESLint, Pylint, Checkstyle и аналоги.\n\nРезультат — улучшенная читаемость, поддерживаемость и производительность кода.\n\n#### 4. **Поиск и устранение уязвимостей**\n\nПроводится анализ безопасности с использованием:\n\n- **SAST** (Static Application Security Testing): анализ исходного кода на уязвимости (например, с помощью SonarQube, Bandit, SpotBugs)\n- **Проверка зависимостей** (SCA): выявление уязвимых библиотек (OWASP Dependency-Check, npm audit, pip-audit)\n- **Анализ по OWASP Top 10** (для веб-приложений): внедрение защит от инъекций, CSRF, небезопасной аутентификации и др.\n\nВсе найденные уязвимости должны быть задокументированы и устранены.\n\n#### 5. **Подготовка отчёта о качестве ПО**\n\nФормируется комплексный отчёт, включающий:\n\n- **Статистику покрытия тестами** (по модулям)\n- **Графики и диаграммы метрик качества кода**\n- **Список найденных и исправленных багов** (с приоритетами и статусами)\n- **Перечень устранённых уязвимостей** (с указанием типа и уровня риска)\n- **Выводы по улучшениям качества и безопасности**\n- **Рекомендации по дальнейшему развитию проекта**\n\nОтчёт оформляется в соответствии с современными стандартами документации (рекомендуется Markdown или PDF с чёткой структурой).\n\n#### 6. **Защита проекта**\n\nНа защите студенты демонстрируют:\n\n- Работу CI/CD-конвейера\n- Примеры автоматических тестов\n- Отчёт о качестве\n- Процесс выявления и устранения уязвимостей\n- Эффект от рефакторинга (до/после по метрикам)\n\nОценивается глубина понимания процессов, качество документации, практическая применимость решений и способность аргументированно отвечать на вопросы.\n\n---\n\n### Критерии оценки\n\n| Критерий | Макс. баллы |\n|---------|------------|\n| Полнота и качество тест-кейсов | 20 |\n| Настройка и работоспособность CI/CD | 20 |\n| Рефакторинг на основе метрик | 15 |\n| Анализ и устранение уязвимостей | 15 |\n| Качество отчёта о качестве ПО | 15 |\n| Защита проекта (демонстрация, ответы на вопросы) | 15 |\n| **Итого** | **100** |\n\n---\n\n### Рекомендации\n\n- Начинайте тестирование как можно раньше (согласно принципу Shift-Left)\n- Используйте автоматизацию для повторяющихся задач\n- Документируйте все действия и решения\n- Применяйте итеративный подход: тестирование → анализ → улучшение → повтор\n\nЭто задание не только проверяет технические навыки, но и формирует культуру качества и ответственности за продукт — ключевые компетенции профессионального разработчика."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Тест по модулю 5: Тестирование, качество и безопасность ПО",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "Опишите ключевые различия между модульным, интеграционным, системным и end-to-end тестированием. Приведите по одному практическому примеру для каждого уровня, основываясь на гипотетическом веб-приложении для онлайн-обучения (например, платформа курсов). Объясните, почему каждый из этих уровней важен для обеспечения общей надёжности системы.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Сравните функциональное и нефункциональное тестирование. Перечислите три вида нефункционального тестирования и опишите, как каждое из них может повлиять на пользовательский опыт в мобильном приложении для заказа еды. Приведите конкретные сценарии, где игнорирование этих видов тестирования привело бы к серьёзным последствиям.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Объясните, в чём заключается принцип «сдвига влево» (Shift-Left) в контексте тестирования и обеспечения качества ПО. Как этот подход интегрируется в Agile-методологию (например, Scrum)? Опишите, на каких этапах спринта QA-специалист должен быть вовлечён, и какие действия он может предпринять для предотвращения дефектов до начала разработки.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Проанализируйте следующую ситуацию: в вашей команде принято решение полностью перейти на автоматизированное тестирование, отказавшись от ручного. Согласны ли вы с этим подходом? Аргументированно объясните, какие преимущества и риски сопряжены с полной автоматизацией. Приведите примеры тестовых сценариев, которые целесообразно автоматизировать, и те, которые лучше оставить в ручном режиме, обосновав свой выбор.",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Вы проводите анализ качества кода своего учебного проекта с помощью SonarQube и обнаруживаете модуль с высокой цикломатической сложностью (например, 25), низким покрытием тестами (30%) и значительным дублированием кода. Опишите пошаговый план рефакторинга этого модуля. Какие конкретные техники рефакторинга вы примените? Как вы будете использовать метрики до и после изменений для оценки эффективности улучшений?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "На основе OWASP Top 10 опишите три наиболее критичные уязвимости веб-приложений. Для каждой уязвимости приведите пример атаки, объясните механизм её работы и предложите конкретные меры по защите (например, использование определённых инструментов, паттернов кодирования или конфигураций). Как можно интегрировать проверку на такие уязвимости в CI/CD-пайплайн?",
            "options": [],
            "correct_answers": [],
            "points": 15
          },
          {
            "text": "Представьте, что вы готовите отчёт о качестве ПО для ретроспективы спринта. Какие метрики вы включите в отчёт и почему? Опишите, как вы визуализируете данные (например, с помощью графиков или дашбордов), чтобы сделать их понятными для всех участников команды, включая нетехнических стейкхолдеров. Какие выводы и рекомендации вы сформулируете на основе этих данных?",
            "options": [],
            "correct_answers": [],
            "points": 10
          }
        ]
      }
    },
    {
      "id": "6fa0c3ea-0fc2-4008-bf65-1702a9f126c8",
      "title": "Модуль 6: Документирование, сопровождение и итоговый проект",
      "description": "В этом модуле студенты завершают цикл обучения, фокусируясь на профессиональном оформлении и поддержке программного продукта. На основе ранее разработанной архитектуры и реализации проекта они создают полный комплект технической документации, осваивают практики сопровождения ПО и проводят финальную презентацию и защиту итогового проекта. Особое внимание уделяется соответствию стандартам (включая ГОСТ), навыкам передачи проекта в эксплуатацию, а также анализу реальных кейсов провальных проектов для формирования культуры ответственной разработки.",
      "learning_objectives": [
        "Создать техническую документацию по ГОСТ и современным стандартам.",
        "Реализовать и протестировать систему, используя практики CI/CD и автоматизированного тестирования.",
        "Применять методологии Agile (Scrum) для управления учебным проектом.",
        "Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.",
        "Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.",
        "Освоить полный жизненный цикл ПО и применять его этапы на практике.",
        "Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок."
      ],
      "order": 6,
      "content_blocks": [
        {
          "content_type": "mermaid",
          "ai_generated": true,
          "title": "Структура модуля 6",
          "mermaid_code": "```mermaid\ngraph TD\n    A[Модуль 6: Документирование, сопровождение и итоговый проект] --> B[Тема 1: Техническая документация по ГОСТ и современным стандартам]\n    A --> C[Тема 2: Сопровождение ПО и передача в эксплуатацию]\n    A --> D[Тема 3: Итоговый проект — реализация и тестирование]\n    A --> E[Тема 4: CI/CD и автоматизированное тестирование]\n    A --> F[Тема 5: Презентация и защита проекта]\n    A --> G[Тема 6: Анализ провалов IT-проектов и уроки для разработки]\n```",
          "explanation": ""
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Введение в модуль\n\nНа этом этапе обучения вы подводите итог всему пройденному: от сбора требований до архитектуры и реализации. Модуль 6 — это финальная точка, где акцент смещается с написания кода на профессиональное оформление, документирование и передачу продукта в эксплуатацию.\n\nВы научитесь:\n- Правильно оформлять техническую документацию по ГОСТ и международным стандартам;\n- Поддерживать ПО после релиза и организовывать его сопровождение;\n- Настройке процессов CI/CD и автоматизированного тестирования;\n- Готовить и защищать итоговый проект перед экспертной аудиторией;\n- Анализировать причины провалов реальных IT-проектов и извлекать уроки.\n\nЭтот модуль формирует у вас системное мышление и готовит к реальным условиям командной разработки."
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 1: Техническая документация по ГОСТ и современным стандартам\n\n### Что вы узнаете\n\nВ процессе разработки программного обеспечения качественная техническая документация играет ключевую роль — она обеспечивает понимание системы между разработчиками, тестировщиками, аналитиками и конечными пользователями. В этом модуле вы познакомитесь с основными видами документации, требованиями отечественных стандартов и современными инструментами, используемыми в IT-индустрии.\n\n#### Виды технической документации\n\n1. **Техническое задание (ТЗ)** — основной документ, определяющий цели, функциональные и нефункциональные требования к программному продукту. Служит основой для проектирования, разработки и тестирования.\n2. **Пояснительная записка** — описывает арххитектуру системы, выбранные технологии, структуру модулей, алгоритмы и обоснование решений. Часто используется в образовательных и государственных проектах.\n3. **Руководство пользователя** — документ, предназначенный для конечных пользователей. Содержит инструкции по установке, настройке и эксплуатации ПО.\n4. **API-документация** — описание интерфейсов программирования, доступных методов, параметров, форматов запросов и ответов. Необходима для интеграции и разработки на стороне.\n\n#### Требования ГОСТ 19 к документированию ПО\n\nСерия ГОСТ 19 (\"Единая система программной документации\", ЕСПД) регламентирует оформление документации на программные средства в России. Основные стандарты:\n\n- **ГОСТ 19.201–78** — Техническое задание. Должно включать:\n  - Введение (наименование, назначение, требования к надёжности, условия эксплуатации);\n  - Функциональные требования;\n  - Интерфейсы (пользовательские, внешние);\n  - Требования к программной документации;\n  - Стадии и этапы разработки;\n  - Порядок контроля и приёмки.\n\n- **ГОСТ 19.402–78** — Техническое описание программы.\n- **ГОСТ 19.502–78** — Руководство оператора.\n- **ГОСТ 19.504–79** — Программа и методика испытаний.\n\nДокументы по ГОСТ должны быть оформлены с соблюдением правил:\n- Единый шрифт (чаще — Times New Roman, 14 кегль);\n- Междустрочный интервал — 1.5;\n- Абзацный отступ — 1.25 см;\n- Нумерация страниц, разделов, приложений;\n- Титульный лист по установленному образцу.\n\n#### Современные подходы к документированию\n\nВ современной разработке ПО активно используются более гибкие и удобные форматы и инструменты:\n\n- **Markdown** — лёгкий язык разметки, идеально подходящий для написания документации в репозиториях (например, README.md). Поддерживает заголовки, списки, таблицы, код.\n- **Swagger (OpenAPI)** — стандарт описания RESTful API. Позволяет автоматически генерировать интерактивную документацию, тестировать методы через веб-интерфейс.\n- **JSDoc / JavaDoc / Sphinx** — инструменты для генерации документации из комментариев в коде. Особенно полезны для внутренней документации.\n- **Read the Docs** — платформа для хостинга документации с поддержкой Sphinx и Markdown. Интегрируется с Git.\n\n#### Инструменты для создания и ведения документации\n\n- **Confluence** — корпоративная платформа Atlassian для совместной работы над документацией. Подходит для командной разработки.\n- **Notion** — гибкая система для ведения заметок, баз знаний, проектной документации. Поддерживает базы данных, вложенные страницы, шаблоны.\n- **GitBook** — инструмент для создания красивой, структурированной документации на основе Markdown. Поддерживает версионность и публикацию в интернет.\n\n### Практическое задание\n\nНа основе вашего итогового проекта выполните следующее:\n\n1. **Создайте Техническое задание по ГОСТ 19.201–78**\n   - Укажите наименование и назначение системы.\n   - Опишите функциональные и нефункциональные требования.\n   - Определите стадии разработки и приёмки.\n   - Оформите документ в соответствии с требованиями ГОСТ (можно использовать шаблон).\n\n2. **Напишите Руководство пользователя в формате Markdown**\n   - Разместите в корне проекта как `USER_GUIDE.md`.\n   - Включите: установку, настройку, основные сценарии использования, скриншоты (если применимо).\n\n3. **API-документация с помощью Swagger (если проект включает API)**\n   - Используйте OpenAPI 3.0 для описания эндпоинтов.\n   - Разместите интерактивную документацию по адресу `/docs` или `/swagger-ui`.\n   - Убедитесь, что все методы задокументированы с примерами запросов и ответов.\n\n### Рекомендуемые ресурсы\n\n- 🔗 [ГОСТ 19.201–78 — Техническое задание на программный продукт](https://docs.cntd.ru/document/1200001)\n- 📁 [Шаблоны документации на GitHub](https://github.com/topics/software-documentation-templates)\n- ▶️ [Видео: «Как писать документацию, которую читают»](https://www.youtube.com/watch?v=example) *(пример ссылки — замените на актуальное видео при использовании)*\n- 📘 [Read the Docs — официальная документация](https://docs.readthedocs.io/)\n- 🐍 [Sphinx Documentation](https://www.sphinx-doc.org/)\n\n> 💡 **Совет**: Хорошая документация — это не только соответствие стандартам, но и удобство восприятия. Пишите так, будто читатель видит ваш проект впервые."
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 2: Сопровождение ПО и передача в эксплуатацию\n\n### Что вы узнаете\n\n#### Этапы сопровождения программного обеспечения\n\nСопровождение программного обеспечения (ПО) — это комплекс мероприятий, направленных на поддержание работоспособности, безопасности и актуальности системы после её внедрения. Согласно международному стандарту **ISO/IEC 14764:2006 «Software maintenance»**, сопровождение включает четыре основных типа активностей:\n\n1. **Корректирующее сопровождение (Corrective Maintenance)**\n   - Исправление выявленных ошибок и сбоев в работе системы.\n   - Включает анализ баг-репортов, воспроизведение дефектов, отладку и внедрение исправлений.\n   - Пример: устранение утечки памяти, приводящей к падению приложения.\n\n2. **Адаптивное сопровождение (Adaptive Maintenance)**\n   - Адаптация ПО к изменениям внешней среды: операционным системам, базам данных, API сторонних сервисов, законодательству.\n   - Пример: обновление интеграции с платёжной системой после изменения её API.\n\n3. **Совершенствующее сопровождение (Perfective Maintenance)**\n   - Улучшение производительности, удобства использования, архитектуры или функциональности.\n   - Часто инициируется на основе обратной связи от пользователей.\n   - Пример: оптимизация времени загрузки страницы или добавление нового фильтра в интерфейсе.\n\n4. **Предупредительное сопровождение (Preventive Maintenance)**\n   - Проактивные меры по предотвращению будущих проблем.\n   - Включает рефакторинг кода, обновление устаревших зависимостей, улучшение документации.\n   - Пример: замена устаревшей библиотеки, в которой обнаружены уязвимости.\n\nЭти этапы не являются строго последовательными — они могут происходить параллельно в течение жизненного цикла ПО.\n\n#### Передача в эксплуатацию (Handover)\n\nПередача в эксплуатацию — это формальный процесс передачи проекта от команды разработки к команде поддержки или эксплуатации. Успешная передача обеспечивает непрерывность работы системы и снижает риски простоев.\n\n**Ключевые компоненты передачи в эксплуатацию:**\n\n- **Чек-лист передачи**\n  - Подтверждение завершения всех тестов (юнит, интеграционных, нагрузочных).\n  - Проверка наличия документации (архитектура, API, инструкции).\n  - Подтверждение настройки мониторинга и логирования.\n  - Проверка резервного копирования и восстановления.\n\n- **Handover-документ**\n  - Описание архитектуры системы.\n  - Схемы взаимодействия компонентов.\n  - Контакты ключевых разработчиков.\n  - Инструкции по развертыванию и обновлению.\n  - Список известных ограничений и рисков.\n\n- **Onboarding для поддержки**\n  - Обучение команды поддержки.\n  - Симуляция типичных инцидентов.\n  - Доступ к системам: CI/CD, мониторингу, системам учёта задач.\n\n**Кейс: Как Netflix передаёт сервисы между командами**\n\nNetflix использует практику **«You Build It, You Run It»**, при которой разработчики несут ответственность за своё ПО в продакшене. При передаче сервисов между командами:\n- Создаются **Service Ownership Documents (SOD)** — аналог handover-документа.\n- Проводятся **handover-сессии** с демонстрацией архитектуры и сценариев сбоев.\n- Обеспечивается доступ к **инструментам мониторинга (Atlas, Zipkin)** и системам алертинга.\n- Назначается **онбординг-ментор** из исходной команды.\n\n#### Работа с баг-репортами и системами учёта задач\n\nЭффективное сопровождение невозможно без систем управления задачами. Популярные инструменты:\n\n- **Jira** — гибкая система для учёта задач, багов, спринтов. Поддерживает Agile-методологии.\n- **YouTrack** — альтернатива от JetBrains, с мощными возможностями фильтрации и автоматизации.\n\n**Жизненный цикл баг-репорта:**\n1. Обнаружение и создание задачи.\n2. Приоритизация (P0 — критический, P1 — высокий и т.д.).\n3. Назначение разработчику.\n4. Воспроизведение и диагностика.\n5. Исправление и тестирование.\n6. Закрытие и верификация.\n\n**Рекомендации по оформлению баг-репорта:**\n- Чёткое описание проблемы.\n- Шаги воспроизведения.\n- Ожидаемое и фактическое поведение.\n- Скриншоты, логи, стектрейсы.\n- Окружение (ОС, браузер, версия ПО).\n\n### Практическое задание\n\n**Цель:** Применить знания по сопровождению и передаче в эксплуатацию на реальном проекте.\n\n**Задачи:**\n\n1. **План сопровождения проекта на 3 месяца**\n   - Определите типы сопровождения (корректирующее, адаптивное и т.д.).\n   - Распределите задачи по месяцам.\n   - Укажите метрики оценки эффективности (например, MTTR — среднее время устранения инцидента).\n\n2. **Handover-документ для команды поддержки**\n   - Включите: архитектурную схему, инструкции по развёртыванию, контакты, известные проблемы.\n   - Используйте структуру, близкую к SOD от Netflix.\n\n3. **Пример обработки инцидента**\n   - Симулируйте баг (например, ошибка 500 при отправке формы).\n   - Опишите: шаги воспроизведения, диагностику, исправление, тестирование.\n   - Оформите как задачу в Jira/YouTrack.\n\n### Ресурсы\n- [ISO/IEC 14764:2006 — Software maintenance](https://www.iso.org/standard/45005.html)\n- Шаблоны handover-документов: [GitHub — DevOps Templates](https://github.com/devops-templates/handover)\n- Кейс: «How Netflix Handles Service Handovers» — доступен в блоге Netflix Tech Blog\n\n> **Совет:** Используйте практики CI/CD и автоматизированного тестирования, чтобы минимизировать риски при обновлениях в период сопровождения."
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 3: Итоговый проект — реализация и тестирование\n\n### Что вы узнаете\n\n#### Завершение разработки: финальная доработка функционала, рефакторинг, подготовка к релизу\n\nНа финальном этапе реализации итогового проекта основное внимание уделяется завершению функциональности, соответствующей концепции MVP (Minimum Viable Product). Это означает, что реализованы все ключевые сценарии использования, определённые на этапе анализа требований. Важно не добавлять избыточные функции, а сосредоточиться на стабильности и качестве уже написанного кода.\n\n**Рефакторинг** — это процесс улучшения внутренней структуры кода без изменения его внешнего поведения. Он включает:\n- Упрощение сложных методов и классов.\n- Устранение дублирования кода.\n- Улучшение читаемости и поддерживаемости.\n- Приведение к единообразному стилю (согласно PEP 8, Google Java Style и т.д.).\n\n**Подготовка к релизу** включает:\n- Версионирование кода (с использованием семантического версионирования — SemVer).\n- Очистку от временных комментариев, отладочных логов и неиспользуемого кода.\n- Настройку сборки и деплоя (через CI/CD).\n- Подготовку changelog и release notes.\n\n---\n\n#### Подходы к тестированию: модульное, интеграционное, сквозное\n\nТестирование — неотъемлемая часть профессиональной разработки. Оно обеспечивает надёжность, упрощает сопровождение и снижает риски при внесении изменений.\n\n| Тип теста | Описание | Уровень | Пример |\n|---------|--------|--------|--------|\n| **Модульное (unit)** | Проверяет отдельные компоненты (функции, методы, классы) изолированно | Низкий | Тестирование функции `calculateTax()` |\n| **Интеграционное (integration)** | Проверяет взаимодействие между модулями или сервисами | Средний | Проверка взаимодействия контроллера и базы данных |\n| **Сквозное (end-to-end, E2E)** | Имитирует поведение пользователя в реальных сценариях | Высокий | Автоматизированный сценарий: «Пользователь регистрируется, добавляет товар в корзину, оформляет заказ» |\n\n**Принцип пирамиды тестирования** предполагает, что большинство тестов должно быть модульными, меньше — интеграционными, и минимальное количество — E2E. Это обеспечивает быстрое выполнение тестов и высокую отдачу от автоматизации.\n\n---\n\n#### Написание тестов: unit, integration, E2E (на примере Jest, PyTest, Selenium и др.)\n\n**Jest (JavaScript/TypeScript)**\n```javascript\n// sum.js\nfunction sum(a, b) { return a + b; }\nmodule.exports = sum;\n\n// sum.test.js\nconst sum = require('./sum');\n\ntest('складывает 1 + 2 и получает 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n**PyTest (Python)**\n```python\n# calculator.py\ndef multiply(x, y):\n    return x * y\n\n# test_calculator.py\ndef test_multiply():\n    assert multiply(3, 4) == 12\n```\n\n**Selenium (E2E, Python/JS)**\n```python\nfrom selenium import webdriver\n\ndef test_login():\n    driver = webdriver.Chrome()\n    driver.get(\"https://example.com/login\")\n    driver.find_element(\"name\", \"username\").send_keys(\"test\")\n    driver.find_element(\"name\", \"password\").send_keys(\"pass\")\n    driver.find_element(\"xpath\", \"//button[@type='submit']\").click()\n    assert \"dashboard\" in driver.current_url\n    driver.quit()\n```\n\n**JUnit (Java)**\n```java\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class MathTest {\n    @Test\n    public void testAdd() {\n        assertEquals(5, Calculator.add(2, 3));\n    }\n}\n```\n\n---\n\n#### Покрытие кода тестами и его анализ\n\n**Покрытие кода (code coverage)** — метрика, показывающая, какой процент исходного кода выполняется в ходе тестирования. Оно измеряется по:\n- **Строкам (lines)** — какой процент строк выполнен.\n- **Функциям (functions)** — какие функции были вызваны.\n- **Ветвлениям (branches)** — какие условия (if/else) были протестированы.\n\n**Инструменты для анализа покрытия**:\n- **JavaScript/TypeScript**: `Istanbul` (встроен в Jest), `nyc`\n- **Python**: `Coverage.py`, `pytest-cov`\n- **Java**: `JaCoCo`\n- **Облачные сервисы**: `Codecov`, `Coveralls` — интегрируются с GitHub и CI/CD.\n\n**Важно**: 70% покрытия — это хороший ориентир, но не цель сама по себе. Критически важные участки (например, расчёт платежей) должны иметь 100% покрытие. Плохой тест с высоким покрытием может быть опаснее, чем его отсутствие.\n\n**Советы по написанию хороших тестов**:\n- Тест должен быть **независимым** (не зависеть от других тестов).\n- **Воспроизводимым** (давать одинаковый результат при каждом запуске).\n- **Читаемым** (понятное имя, структура AAA: Arrange-Act-Assert).\n- **Быстрым** (особенно unit-тесты).\n- Проверять **одно поведение** за тест.\n\n---\n\n### Практическое задание\n\n1. **Доработайте итоговый проект до состояния MVP**\n   - Убедитесь, что реализованы все ключевые пользовательские сценарии.\n   - Проведите рефакторинг: устраните дублирование, улучшите архитектуру.\n   - Подготовьте проект к релизу: настройте сборку, версионирование, документацию.\n\n2. **Напишите набор автоматизированных тестов (не менее 70% покрытия)**\n   - Реализуйте unit-тесты для ключевых модулей.\n   - Добавьте интеграционные тесты для взаимодействия между компонентами.\n   - Создайте хотя бы один E2E-тест для основного сценария.\n   - Настройте инструмент анализа покрытия и представьте отчёт.\n\n3. **Проведите внутренний ревью-цикл в команде**\n   - Организуйте код-ревью через pull request.\n   - Проверьте соответствие стилю, наличие тестов, читаемость.\n   - Используйте чек-лист ревью: наличие документации, покрытие тестами, безопасность, производительность.\n\n---\n\n### Ресурсы\n\n- **Документация по фреймворкам**:\n  - [Jest Documentation](https://jestjs.io/)\n  - [PyTest Documentation](https://docs.pytest.org/)\n  - [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)\n  - [Selenium WebDriver — Python](https://selenium-python.readthedocs.io/)\n\n- **Инструменты анализа покрытия**:\n  - [Coverage.py](https://coverage.readthedocs.io/)\n  - [Istanbul (nyc)](https://istanbul.js.org/)\n  - [Codecov](https://about.codecov.io/)\n\n- **Гайды и лучшие практики**:\n  - [Google Testing Blog](https://testing.googleblog.com/)\n  - [Martin Fowler — Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html)\n  - [«How to Write Good Unit Tests» — Refactoring Guru](https://refactoring.guru/ru/testing-antipatterns)\n\n---\n\n> **Примечание**: Успешный итоговый проект — это не только работающий код, но и доказательство его надёжности через тесты, документацию и командную дисциплину. Эти навыки критически важны для профессиональной карьеры в IT."
        },
        {
          "content_type": "quiz",
          "ai_generated": true,
          "questions": []
        },
        {
          "content_type": "text",
          "ai_generated": true,
          "md_content": "## Тема 4: CI/CD и автоматизированное тестирование\n\n### Что вы узнаете\n\n#### Понятие CI/CD: непрерывная интеграция и доставка\n\nCI/CD (Continuous Integration / Continuous Delivery или Continuous Deployment) — это набор практик разработки программного обеспечения, направленных на ускорение и повышение надёжности выпуска обновлений. Эти процессы лежат в основе современной DevOps-культуры и позволяют командам быстро и безопасно доставлять изменения в продакшн.\n\n- **Непрерывная интеграция (CI)** — практика, при которой разработчики регулярно (часто несколько раз в день) сливают свои изменения в общую ветку (например, `main` или `develop`). Каждое такое слияние автоматически проверяется с помощью сборки и запуска тестов, чтобы как можно раньше выявить ошибки.\n  \n- **Непрерывная доставка (Continuous Delivery)** — расширение CI, при котором код после успешной сборки и тестирования автоматически готов к развёртыванию в продакшн. Развёртывание может быть ручным, но процесс должен быть полностью автоматизирован и безопасным.\n\n- **Непрерывное развёртывание (Continuous Deployment)** — более продвинутая форма, при которой каждое успешное изменение автоматически попадает в продакшн без участия человека. Требует высокого уровня автоматизации тестирования и мониторинга.\n\n#### Настройка пайплайнов: GitHub Actions, GitLab CI, Jenkins\n\nПайплайн (pipeline) — это последовательность шагов, которые выполняются при каждом изменении кода. Он описывается в конфигурационном файле и запускается автоматически.\n\n- **GitHub Actions** — встроенная система CI/CD в GitHub. Пайплайны описываются в файле `.github/workflows/*.yml`. Подходит для проектов на GitHub, легко интегрируется с репозиторием.\n\n- **GitLab CI** — встроенная система в GitLab. Конфигурация находится в файле `.gitlab-ci.yml`. Обладает широкими возможностями, включая раннеры, артефакты и динамические окружения.\n\n- **Jenkins** — мощная, гибкая, но более сложная в настройке система с открытым исходным кодом. Подходит для сложных и масштабируемых пайплайнов. Требует отдельного сервера и поддержки.\n\n#### Этапы пайплайна: тесты, линтинг, сборка, деплой\n\nТипичный CI/CD-пайплайн состоит из следующих этапов:\n\n1. **Checkout** — клонирование репозитория.\n2. **Установка зависимостей** — установка пакетов (например, `npm install`, `pip install -r requirements.txt`).\n3. **Линтинг кода** — проверка стиля и качества кода с помощью инструментов (например, ESLint, Prettier, Flake8).\n4. **Запуск тестов** — выполнение unit-, integration- и end-to-end тестов. Пайплайн останавливается при ошибках.\n5. **Сборка** — создание артефактов (например, Docker-образов, минифицированных файлов).\n6. **Деплой** — развёртывание на staging- или production-среду. Часто сопровождается уведомлениями и проверками.\n\n#### Best practices: быстрые фидбэки, изоляция сред, безопасность\n\n- **Быстрая обратная связь** — пайплайн должен завершаться быстро (желательно за 5–10 минут), чтобы разработчики оперативно получали результат.\n- **Изоляция сред** — staging-среда должна максимально приближаться к продакшн. Используйте Docker и окружения (environments) для избежания «у меня работало».\n- **Безопасность** — не храните секреты в коде. Используйте переменные окружения и секреты в системе CI/CD (например, GitHub Secrets).\n- **Идемпотентность** — повторный запуск пайплайна должен давать одинаковый результат.\n- **Мониторинг и логирование** — сохраняйте логи и уведомляйте команду о статусе сборок.\n\n### Практическое задание\n\n**Цель**: Настроить CI/CD-пайплайн для вашего итогового проекта.\n\n**Шаги**:\n\n1. **Автоматический запуск тестов при пуше в ветку `main` или `develop`**\n   - Создайте файл конфигурации (например, `.github/workflows/test.yml`).\n   - Настройте запуск тестов при событии `push`.\n\n2. **Линтинг кода**\n   - Добавьте шаг с запуском линтера (например, `npm run lint` или `flake8 .`).\n   - Убедитесь, что пайплайн падает при ошибках линтинга.\n\n3. **Сборка и деплой на staging-среду**\n   - Настройте сборку проекта (например, `npm run build`).\n   - Настройте автоматическое развёртывание на staging (например, через Vercel, Heroku или Render). Используйте секреты для API-ключей.\n\n**Пример для GitHub Actions (Node.js-проект)**:\n```yaml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main, develop ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Lint code\n      run: npm run lint\n\n    - name: Run tests\n      run: npm test\n\n    - name: Build\n      run: npm run build\n\n    - name: Deploy to Vercel (staging)\n      if: github.ref == 'refs/heads/develop'\n      run: |\n        curl -X POST \\\n          -H \"Content-Type: application/json\" \\\n          -H \"Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}\" \\\n          -d '{\"target\":\"staging\"}' \\\n          https://api.vercel.com/v1/integrations/deploy/prj_xxx/xyz\n```\n\n> **Примечание**: Замените `VERCEL_TOKEN` на реальный токен, сохранённый в GitHub Secrets.\n\n### Ресурсы\n- [GitHub Actions — официальная документация](https://docs.github.com/en/actions)\n- [GitLab CI/CD Documentation](https://docs.gitlab.com/ee/ci/)\n- [Jenkins User Handbook](https://www.jenkins.io/doc/book/)\n- [Шаблоны CI/CD для разных стеков (например, на GitHub)](https://github.com/marketplace?type=actions)\n- Видео: [«Как не сломать продакшн: безопасный CI/CD»](https://www.youtube.com/watch?v=example) (пример; замените на актуальную ссылку)\n\n> **Совет**: Изучите реальные кейсы провалов из-за плохого CI/CD (например, деплой без тестов, отсутствие staging). Это поможет избежать критических ошибок в будущем."
        }
      ],
      "assignment": {
        "assignment_type": "test",
        "version": 0,
        "title": "Создать техническую документацию по ГОСТ и современным стандартам: ТЗ, руководство пользователя, API-документация",
        "max_score": 100,
        "passing_score": 70,
        "questions": [
          {
            "text": "На основе вашего итогового проекта разработайте Техническое задание (ТЗ) в соответствии с ГОСТ 19.201–78. Включите следующие разделы: наименование и назначение системы, функциональные и нефункциональные требования, описание интерфейсов (пользовательских и внешних), стадии и этапы разработки, а также порядок контроля и приёмки. Объясните, как вы адаптировали современные практики (например, пользовательские истории или диаграммы UML) под структуру классического ТЗ по ГОСТ. Какие сложности возникли при этом, и как вы их преодолели?",
            "options": [],
            "correct_answers": [],
            "points": 30
          },
          {
            "text": "Создайте Руководство пользователя вашего проекта в формате Markdown (файл USER_GUIDE.md в корне репозитория). Документ должен включать: инструкции по установке и настройке, описание основных сценариев использования, информацию о поддержке и устранении типовых неполадок. Обоснуйте выбор формата Markdown для данного типа документации. Какие преимущества он даёт по сравнению с традиционными текстовыми редакторами (например, Word)? Как вы обеспечили удобочитаемость и структурированность документа?",
            "options": [],
            "correct_answers": [],
            "points": 25
          },
          {
            "text": "Если ваш проект включает веб-API, разработайте его документацию с использованием OpenAPI 3.0 (Swagger). Документация должна быть доступна по маршруту /docs или /swagger-ui и содержать описания всех эндпоинтов, включая HTTP-методы, параметры запросов, форматы тел запросов и ответов, коды состояния, а также примеры. Объясните, как автоматическая генерация документации на основе кода (например, через аннотации в Spring Boot или декораторы в FastAPI) влияет на её актуальность и качество. Какие риски возникают при несогласованности между кодом и документацией, и как их можно минимизировать?",
            "options": [],
            "correct_answers": [],
            "points": 30
          },
          {
            "text": "Сравните два подхода к ведению технической документации: традиционный (по ГОСТ, с жёсткой структурой и формальным стилем) и современный (гибкий, на основе Markdown, в репозитории, с интеграцией в CI/CD). В каких типах проектов каждый из подходов наиболее эффективен? Приведите примеры (например, государственный заказ, стартап, корпоративный продукт). Как можно объединить сильные стороны обоих подходов в одном проекте?",
            "options": [],
            "correct_answers": [],
            "points": 15
          }
        ]
      }
    }
  ],
  "final_assessment": null
}