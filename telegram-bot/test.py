import asyncio
import logging
from uuid import uuid4

import anyio
from langchain_core.runnables.graph import MermaidDrawMethod

from src.core.entities.course import Course
from src.infra.ai import rag
from src.infra.ai.agents.course_generator.schemas import TeacherContext
from src.infra.ai.agents.course_generator.workflow import agent
from src.utils.docs_processing import convert_document_to_md

user_id = 123
tenant_id = str(12345)
comment = """\
Название курса: `Инженерия программного обеспечения`
Курс предназначен для студентов 3 курса IT направлений, рассчитан на 1 семестр.
По большей части курс является теоретическим, также я подгрузил 3 лекции,
используй из них учебный материал.
"""

thinks = """\
## 1. Название курса
Инженерия программного обеспечения

## 2. Целевая аудитория (детальное описание)
- Возраст / опыт / бэкграунд: студенты 3 курса IT-направлений (программная инженерия, прикладная информатика, компьютерные науки), возраст 19–21 год, имеют опыт программирования на одном из языков (Java, Python, C#), знакомы с основами ООП, базами данных и веб-разработкой.
- Главные боли / проблемы / мотивации: не понимают, как перейти от написания кода к проектированию систем; сталкиваются с трудностями при работе в команде; не видят связи между теорией и практикой; мотивированы к созданию качественного, поддерживаемого ПО, но не знают, с чего начать.
- Что уже умеют (реальный стартовый уровень): пишут программы средней сложности, используют Git, проектируют простые базы данных, знакомы с основами тестирования.
- Что категорически НЕ умеют / не понимают: системный подход к разработке, архитектурные паттерны, управление требованиями, нефункциональные требования, документирование архитектуры, оценку качества ПО.

## 3. Продолжительность и примерный объём курса
- 14 недель (1 семестр)
- 14 модулей (1 модуль в неделю)
- Общая нагрузка: 90 часов (36 аудиторных + 54 самостоятельные)

## 4. Главные учебные цели курса (5–8 самых важных)
1. Понимать жизненный цикл разработки ПО и применять его этапы на практике.
2. Собирать, анализировать и документировать функциональные и нефункциональные требования.
3. Проектировать архитектуру ПО с учётом масштабируемости, надёжности и поддерживаемости.
4. Применять архитектурные паттерны (монолит, микросервисы, слоистая архитектура) и обосновывать их выбор.
5. Документировать архитектурные решения по шаблону C4.
6. Разрабатывать стратегию тестирования, включая нефункциональные аспекты.
7. Оценивать качество ПО и управлять техническим долгом.
8. Работать в команде, использовать инструменты трассируемости требований и управления изменениями.

## 5. Рекомендуемая структура (модули / блоки)
1. Введение в инженерию ПО  
2. Жизненный цикл разработки ПО  
3. Сбор и анализ требований  
4. Управление изменениями требований  
5. Архитектура ПО: основные понятия  
6. Архитектурные стили и паттерны  
7. Проектирование масштабируемых систем  
8. Безопасность в архитектуре  
9. Документирование архитектуры (C4 model)  
10. Введение в тестирование ПО  
11. Тестирование архитектуры и нефункциональных требований  
12. Управление качеством и техническим долгом  
13. Современные практики: CI/CD, DevOps  
14. Финальный проект и защита

## 6. Ключевые темы и подтемы (детализация по модулям)
- Модуль 1: Введение в инженерию ПО  
  • Отличие программирования от инженерии ПО  
  • История развития дисциплины  
  • Этические и профессиональные аспекты

- Модуль 2: Жизненный цикл разработки ПО  
  • Каскадная, итеративная, гибкая модели  
  • Выбор модели в зависимости от проекта  
  • Роли в команде разработки

- Модуль 3: Сбор и анализ требований  
  • Функциональные и нефункциональные требования  
  • Методы сбора (интервью, анкетирование, use cases)  
  • Матрица трассируемости требований

- Модуль 4: Управление изменениями требований  
  • Анализ влияния изменений  
  • Версионирование требований  
  • Работа с заказчиком в условиях неопределённости

- Модуль 5: Архитектура ПО: основные понятия  
  • Что такое архитектура и зачем она нужна  
  • Качественные атрибуты (производительность, надёжность, безопасность)  
  • Архитектурные решения и компромиссы

- Модуль 6: Архитектурные стили и паттерны  
  • Монолит, микросервисы, серверлесс  
  • Слоистая архитектура, hexagonal, event-driven  
  • Сравнение и выбор подхода

- Модуль 7: Проектирование масштабируемых систем  
  • Горизонтальное и вертикальное масштабирование  
  • Балансировка нагрузки, кэширование, репликация БД  
  • Проектирование с учётом роста

- Модуль 8: Безопасность в архитектуре  
  • Угрозы и уязвимости на уровне архитектуры  
  • Принципы безопасного проектирования (least privilege, defence in depth)  
  • Архитектурные паттерны безопасности

- Модуль 9: Документирование архитектуры (C4 model)  
  • Уровни C4: Context, Containers, Components, Code  
  • Диаграммы и их назначение  
  • Инструменты (Structurizr, PlantUML)

- Модуль 10: Введение в тестирование ПО  
  • Уровни тестирования (модульное, интеграционное, системное)  
  • Виды тестирования (функциональное, нагрузочное, безопасность)  
  • Роль тестирования в жизненном цикле

- Модуль 11: Тестирование архитектуры и нефункциональных требований  
  • Нагрузочное тестирование прототипов  
  • Проверка отказоустойчивости  
  • Архитектурные тесты (например, проверка слабой связанности)

- Модуль 12: Управление качеством и техническим долгом  
  • Оценка качества ПО (метрики, рефакторинг)  
  • Технический долг: причины, оценка, управление  
  • Архитектурная эволюция

- Модуль 13: Современные практики: CI/CD, DevOps  
  • Непрерывная интеграция и доставка  
  • Автоматизация тестирования и развёртывания  
  • Роль архитектора в DevOps

- Модуль 14: Финальный проект и защита  
  • Проектирование системы от требования до архитектуры  
  • Документирование и презентация решения  
  • Защита перед «комитетом заказчиков»

## 7. Самые частые заблуждения / типичные ошибки учеников
- Считают, что архитектура — это просто диаграмма классов.
- Пропускают этап анализа нефункциональных требований.
- Выбирают микросервисы для простых приложений (овер-инжиниринг).
- Проектируют без учёта масштабируемости и безопасности.
- Сильно связывают компоненты, что затрудняет тестирование.
- Тестируют только функциональность, игнорируя производительность и отказоустойчивость.
- Не документируют архитектурные решения и компромиссы.
- Считают, что технический долг — это норма, а не риск.

## 8. Лучшие практические примеры / кейсы / задачи
- Кейс 1: Проектирование интернет-магазина — сравнить монолит и микросервисы, обосновать выбор.
- Кейс 2: Модернизация legacy-системы — выявить архитектурные проблемы и предложить улучшения.
- Кейс 3: Управление требованиями — построить матрицу трассируемости для системы бронирования.
- Кейс 4: Безопасность — проанализировать архитектуру на уязвимости и предложить защиту.
- Кейс 5: Нагрузочное тестирование — смоделировать рост нагрузки и предложить решения.
- Практическое задание: Найти ошибки в «плохой» архитектуре (анализ кейса с типичными ошибками).
- Лабораторная: Построить диаграммы C4 для существующего open-source проекта.

## 9. Способы проверки понимания (если известны или рекомендуются)
- Тесты по каждому модулю (теория)
- Практические задания с проверкой (диаграммы, документы)
- Промежуточные презентации решений
- Финальный проект с защитой
- Рецензирование архитектурных решений одногруппников (peer review)
- Оценка по критериям: полнота требований, обоснованность архитектуры, качество документации

## 10. Важные акценты / подводные камни / «ловушки» материала
- Акцент на компромиссах: нет идеальных решений, только обоснованные.
- Подчеркивать разницу между проектированием для "сейчас" и "в будущем".
- Учить студентов задавать вопросы: "А что, если пользователей станет в 10 раз больше?"
- Избегать излишнего усложнения — простое решение лучше сложного.
- Делать упор на документирование: архитектура — это не только код, но и коммуникация.
- Не отрывать теорию от практики: каждая лекция должна сопровождаться примером или кейсом.

## 11. Что не учтено или требует уточнения (если остались вопросы к преподавателю)
- Требуется уточнение: какие именно 3 лекции были загружены — можно ли использовать их как основу для модулей 1–3?
- Нужно знать: предполагается ли доступ к инструментам визуализации (например, PlantUML, Structurizr)?
- Важно уточнить: возможно ли проведение защиты проекта в формате ролевой игры с "заказчиками"?
- Требуется решение: будет ли финальный проект индивидуальным или командным?
"""  # noqa: E501

context = TeacherContext(user_id=user_id, tenant_id=tenant_id, comment=comment)


async def main() -> None:
    """# Индексация материалов преподавателя
    materials_dir = anyio.Path("materials")
    async for file_path in materials_dir.iterdir():
        content = await file_path.read_bytes()
        md_text = convert_document_to_md(content, file_extension=file_path.suffix)
        metadata = {
            "user_id": user_id,
            "tenant_id": tenant_id,
            "category": "materials",
            "source": file_path.name
        }
        rag.indexing(md_text, metadata=metadata)

    """

    # Запуск агента - генератора курсов
    result = await agent.ainvoke({"teacher_context": context, "thinks": thinks})

    # Сохранение сгенерированного курса
    course: Course = result["course"]
    file_name = "Инженерия_программного_обеспечения_2.json"
    payload = course.model_dump_json(indent=2, ensure_ascii=False)
    await anyio.Path(file_name).write_text(payload, encoding="utf-8")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
