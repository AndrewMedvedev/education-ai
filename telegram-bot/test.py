import asyncio
import logging
from uuid import uuid4

import anyio

from app.core.entities.course import Course
from app.infra.ai import rag
from app.infra.ai.agents.course_generator.schemas import TeacherContext
from app.infra.ai.agents.course_generator.workflow import agent
from app.utils.preprocessing import convert_document_to_md

user_id = 123
tenant_id = str(uuid4())
comment = """\
Название курса: `Инженерия программного обеспечения`
Курс предназначен для студентов 3 курса IT направлений, рассчитан на 1 семестр.
По большей части курс является теоретическим, также я подгрузил 3 лекции,
используй из них учебный материал.
"""

thinks = """\
## 1. Название курса
Инженерия программного обеспечения

## 2. Целевая аудитория (детальное описание)
- Возраст / опыт / бэкграунд: Студенты 3 курса IT-направлений (программная инженерия, прикладная информатика, компьютерные науки), возраст 19–21 год. Имеют базовые знания по программированию (на Python, Java или C++), знакомы с основами баз данных и алгоритмов.
- Главные боли / проблемы / мотивации: Студенты понимают, что "писать код" — это не всё; им сложно представить, как создаются большие системы, как управляются требования, документация и команды. Мотивированы карьерой в IT, но не осознают важность инженерных практик (тестирование, моделирование, документирование) до тех пор, пока не сталкиваются с последствиями их отсутствия.
- Что уже умеют (реальный стартовый уровень): Пишут программы, работают с Git на уровне "commit/push", могут создать простое веб-приложение. Имеют поверхностное представление о жизненном цикле ПО.
- Что категорически НЕ умеют / не понимают: Как формализовать требования, строить UML-диаграммы, проектировать архитектуру, оценивать риски, работать в команде по Agile, писать техническую документацию по стандартам.

## 3. Продолжительность и примерный объём курса
- 14 недель (1 семестр)
- 56 академических часов: 28 ч лекций, 28 ч практики
- 7 модулей по 2 недели каждый

## 4. Главные учебные цели курса (5–8 самых важных)
1. Освоить полный жизненный цикл ПО и применять его этапы на практике.
2. Формализовать функциональные и нефункциональные требования с использованием UML и пользовательских историй.
3. Разработать архитектуру и модели ПО (Use Case, диаграммы последовательности, классов) с соблюдением стандартов.
4. Применять методологии Agile (Scrum) для управления учебным проектом.
5. Реализовать и протестировать систему, используя практики CI/CD и автоматизированного тестирования.
6. Создать техническую документацию по ГОСТ и современным стандартам (включая ТЗ, спецификации, руководства).
7. Проанализировать причины провалов реальных IT-проектов и выработать стратегии предотвращения ошибок.

## 5. Рекомендуемая структура (модули / блоки)
- Модуль 1: Введение в инженерное мышление и жизненный цикл ПО
- Модуль 2: Анализ и спецификация требований
- Модуль 3: Проектирование ПО и UML-моделирование
- Модуль 4: Управление проектом и командная разработка (Agile/Scrum)
- Модуль 5: Реализация, рефакторинг и технический долг
- Модуль 6: Тестирование, качество и безопасность ПО
- Модуль 7: Документирование, сопровождение и итоговый проект

## 6. Ключевые темы и подтемы (детализация по модулям)
- Модуль 1: Введение в инженерное мышление и жизненный цикл ПО  
  • Что такое инженерия ПО: отличие от программирования  
  • Модели жизненного цикла: водопад, спираль, итеративная, Agile  
  • Стандарты: ISO/IEC 12207, CMMI  
  • Кейс-стади: Therac-25 — как ошибка в ПО привела к смерти  
  • Практика: анализ кейса, ответы на вопросы, обсуждение в группах  

- Модуль 2: Анализ и спецификация требований  
  • Сбор требований: интервью, анкетирование, наблюдение  
  • Функциональные и нефункциональные требования  
  • Пользовательские истории, шаблон "Как [роль], я хочу [действие], чтобы [цель]"  
  • Диаграммы Use Case: актёры, отношения include/extend, обобщение  
  • Практика: создание Use Case для "Системы управления курсами", задание "найди 5 ошибок в примере диаграммы"  

- Модуль 3: Проектирование ПО и UML-моделирование  
  • Объектно-ориентированный анализ и проектирование (OOAD)  
  • Диаграммы классов, последовательности, состояний  
  • Паттерны проектирования: Singleton, Factory, Observer (на примерах)  
  • Практика: построение диаграммы последовательности для "Оплаты курса", использование фреймов alt/loop/opt  

- Модуль 4: Управление проектом и командная разработка  
  • Agile и Scrum: роли, артефакты, события  
  • Работа с Jira: бэклог, спринты, задачи, барчарт  
  • Распределение ролей: Scrum Master, Product Owner, Developer  
  • Практика: симуляция 2-недельного спринта, daily stand-up, ретроспектива  

- Модуль 5: Реализация, рефакторинг и технический долг  
  • Код-ревью и парное программирование  
  • Управление техническим долгом: причины, оценка, стратегии погашения  
  • Рефакторинг: примеры (извлечение метода, замена условного оператора полиморфизмом)  
  • Практика: рефакторинг устаревшего кода, анализ "запахов кода"  

- Модуль 6: Тестирование, качество и безопасность ПО  
  • Виды тестирования: модульное, интеграционное, системное, acceptance  
  • Методы: чёрный/белый ящик, TDD  
  • Автоматизация: JUnit, Selenium, Postman  
  • Кейс: Knight Capital — ошибка деплоя, стоившая $440 млн  
  • Практика: написание тестов для учебного проекта, анализ рисков деплоя  

- Модуль 7: Документирование, сопровождение и итоговый проект  
  • Стандарты документации: ГОСТ 19 (ТЗ, спецификации), ISO/IEC 26514  
  • Виды документации: техническая, пользовательская, API  
  • Управление конфигурацией: Git, ветвление (GitFlow), CI/CD  
  • Практика: создание ТЗ по ГОСТ, настройка пайплайна в GitHub Actions  

## 7. Самые частые заблуждения / типичные ошибки учеников
- Считают UML "лишней бюрократией", не видят её практической ценности.
- Путают отношения `include` и `extend` в Use Case.
- Добавляют "Базу данных" как актёра в диаграммы.
- Формулируют требования размыто: "система должна быть быстрой".
- Игнорируют нефункциональные требования (безопасность, отказоустойчивость).
- Не понимают разницы между водопадной и Agile-моделями.
- Считают, что тестирование — это "не их задача".
- Не видят ценности документации, если "и так всё понятно".

## 8. Лучшие практические примеры / кейсы / задачи
- **Кейс Therac-25**: анализ причин сбоев, обсуждение роли требований и тестирования.
- **Кейс Knight Capital**: моделирование процесса деплоя, выявление рисков.
- **Задание "Найди ошибку"**: диаграмма с намеренными UML-ошибками — студенты исправляют.
- **Создание пользовательских историй в Jira**: настройка проекта, приоритизация.
- **Рефакторинг legacy-кода**: упрощённый пример с "запахами кода".
- **Построение CI/CD пайплайна**: автоматизация тестов и деплоя в GitHub.
- **Сквозной проект "Система управления курсами"**: развивается по модулям от требований до документации.

## 9. Способы проверки понимания (если известны или рекомендуются)
- Мини-тесты после каждого модуля (теория + интерпретация диаграмм).
- Проверка UML-диаграмм по чек-листу: наличие актёров, корректность отношений, стандарты.
- Оценка командного проекта по критериям: полнота требований, качество кода, покрытие тестами, документация.
- Peer review: студенты оценивают работы друг друга по шаблону.
- Защита итогового проекта с демонстрацией всех артефактов (ТЗ, диаграммы, код, тесты).

## 10. Важные акценты / подводные камни / «ловушки» материала
- **Мотивация**: начните с кейсов провалов — покажите, что ошибки в инженерии ПО имеют реальные последствия.
- **Практика до теории**: давайте студентам сначала попробовать создать диаграмму, потом — разбирать ошибки.
- **Единый сквозной проект**: все модули должны развивать один и тот же учебный продукт.
- **Инструменты = часть обучения**: не просто упоминайте Jira/Git, а требуйте их активного использования.
- **Командная работа**: предусмотрите чёткие роли, шаблоны встреч и оценку вклада каждого.
- **Обратная связь**: регулярные короткие ревью артефактов, а не только итоговая оценка.

## 11. Что не учтено или требует уточнения (если остались вопросы к преподавателю)
- Требуется уточнение: какие именно 3 лекции были загружены? Нужно их интегрировать в структуру.
- Неясно, есть ли доступ к инструментам (Jira, Confluence, GitHub Education)? Если нет — нужны альтернативы.
- Требуется решение: будет ли курс включать защиту проекта перед "внешними" экспертами (приглашёнными разработчиками)?
- Нужно определиться: будет ли оцениваться вклад каждого студента в командный проект и каким образом?
"""  # noqa: E501

context = TeacherContext(user_id=user_id, tenant_id=tenant_id, comment=comment)


async def main() -> None:
    # Индексация материалов преподавателя
    """materials_dir = anyio.Path("materials")
    async for file_path in materials_dir.iterdir():
        content = await file_path.read_bytes()
        md_text = convert_document_to_md(content, file_extension=file_path.suffix)
        metadata = {
            "user_id": user_id,
            "tenant_id": tenant_id,
            "source": file_path.name
        }
        rag.indexing(md_text, metadata=metadata)"""

    # Запуск агента - генератора курсов
    result = await agent.ainvoke({"teacher_context": context, "thinks": thinks})

    # Сохранение сгенерированного курса
    course: Course = result["course"]
    file_name = "Инженерия_программного_обеспечения.json"
    payload = course.model_dump_json(indent=2, ensure_ascii=False)
    await anyio.Path(file_name).write_text(payload, encoding="utf-8")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
